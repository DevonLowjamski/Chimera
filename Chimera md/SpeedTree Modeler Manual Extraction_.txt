The Definitive Compendium of SpeedTree Modeler 10: An Exhaustive Technical Manual
Part I: Introduction to SpeedTree Modeler 10
Section 1.1: The SpeedTree Ecosystem: Purpose and Philosophy
SpeedTree Modeler stands as a specialized software solution meticulously engineered for the creation and manipulation of three-dimensional vegetation. Its core purpose is to provide artists and developers across various industries, including game development, visual effects (VFX), and architectural visualization (ArchViz), with a robust toolkit for generating highly realistic and optimized trees and plants.1 The SpeedTree ecosystem encompasses not only the Modeler application itself but also a substantial library of pre-built tree assets and scanned materials, designed to accelerate production workflows.2
The development philosophy underpinning SpeedTree emphasizes a synergistic blend of procedural generation for efficiency and artistic control for nuanced detail. This dual focus allows for the rapid creation of complex botanical structures that can then be finely tuned to meet specific aesthetic or technical requirements. The evolution of SpeedTree, from its earlier iterations to the current SpeedTree Modeler 10, reflects a continuous commitment to enhancing this core philosophy. Version 10, for instance, introduces significant advancements such as physics-based vine generation, more intuitive freehand pruning tools, and enhanced capabilities for rigging custom mesh assets, alongside an expanded Tree Library.2
This ongoing development, spanning multiple versions (from SpeedTree 7 through 10 as referenced in documentation 1), demonstrates the adaptability and resilience of its core technology. The software has consistently evolved to incorporate new industry standards, such as Physically Based Rendering (PBR), and to address the increasing demands for complexity and realism in both real-time and offline rendering pipelines. This sustained development trajectory suggests a mature and well-supported platform. Furthermore, a notable strategic shift occurred with SpeedTree 9, which introduced an "engine agnostic" approach for its Games tools.2 This change provides users with greater flexibility, allowing them to utilize the Modeler across various game engines and custom pipelines without being tied to engine-specific versions of the software, thereby simplifying licensing and broadening compatibility.
Section 1.2: Core Modeling Paradigm: Procedural Generation and Artistic Control
The fundamental modeling approach in SpeedTree Modeler is characterized by a powerful combination of procedural algorithms and direct manual editing techniques.5 This hybrid paradigm, often referred to as "The SpeedTree Way" 6, is designed to tackle the inherent complexity of vegetation, which is typically too intricate and time-consuming to model efficiently by hand.5
The backbone of the system lies in procedural modeling. Tree models are constructed by establishing a hierarchical arrangement of objects known as "generators." Each generator acts as a set of rules that defines how a particular part of the tree—such as the trunk, branches, leaves, or fronds—grows and forms. These generators, in turn, create multiple instances of geometry called "nodes".5 For example, a single "Branch" generator can produce numerous individual branch nodes on a tree, each adhering to the properties defined within that generator but also capable of unique variations.
The typical workflow involves initially "roughing out" the model using these procedural techniques. Artists define the overall structure, distribution, and characteristics of tree components by adjusting the properties of their respective generators. Once a satisfactory base form is achieved, the model can be fine-tuned using a variety of artistic controls. These include editing curves that influence property behaviors, directly manipulating individual nodes to adjust their position or form, and employing freehand drawing tools to sculpt or place branches with precision.5 While the specific documentation page for "Modeling approach" in SpeedTree Modeler 10 was not directly accessible 7, its prominent listing in the manual's structure 8 and the detailed descriptions available for earlier versions 5 confirm its centrality to the software's design.
This hybrid approach directly addresses the challenge of balancing scale and detail in vegetation modeling. Purely manual methods are impractical for the sheer number of elements in a complex tree, while purely procedural systems can sometimes lack the specific artistic nuances required for high-quality assets. SpeedTree's methodology aims to provide an optimal balance. A key element supporting this non-destructive workflow is the concept of "node edits as offsets".5 When an artist modifies an individual node, these changes are stored as deviations from the values calculated by its parent generator. This means that global changes can still be made at the generator level without overwriting the specific artistic tweaks applied to individual nodes, allowing for remarkable flexibility and iteration.
Section 1.3: Installation, Licensing, and Initial Setup
The initial phase of utilizing SpeedTree Modeler involves installation and license activation. The user manual for SpeedTree Modeler 10 includes a dedicated section for "Installation" 3, which would provide specific instructions for the setup process. While system requirements for version 10 are not detailed in the provided materials, documentation for version 9 indicates typical hardware and software prerequisites 10, which are likely to be comparable for version 10, demanding a capable graphics card and sufficient system memory for handling complex 3D scenes.
SpeedTree offers a tiered licensing model designed to accommodate a diverse user base, from individuals and small studios to large enterprises. Options typically include:
* Learning Editions: Often provided free of charge, these versions allow users to explore the software's full feature set but usually come with restrictions, most notably the inability to export models for use in external applications or commercial projects.2
* Indie Subscriptions: Aimed at independent developers and small teams, these licenses are offered at a more accessible price point, often on a monthly subscription basis. For SpeedTree 9 and 10, Indie subscriptions start at $19 per month.2
* Pro Licenses: Designed for professional studios and larger projects, these licenses offer the full capabilities of the software for commercial use and typically involve a higher cost.2
* Evaluation Licenses: New users can often start with a built-in 30-day evaluation period upon installing the Modeler, allowing them to test the software before committing to a purchase.2
It is important to note that SpeedTree 9 and 10 are the current versions available for new license purchases, with support and updates focused on these iterations. While older licenses for versions like SpeedTree 8 may continue to be honored, new features and bug fixes are primarily directed towards the latest releases.2 The tiered licensing structure facilitates broad adoption by lowering the initial barrier to entry for learning and experimentation, while providing scalable solutions for professional and commercial endeavors.
Section 1.4: File Operations: Creation, Management, and Formats (.spm,.st,.st9)
SpeedTree Modeler utilizes its own native file format, .spm, for saving tree models and their associated data.11 The software provides a standard suite of file operations accessible via the "File" menu:
* New: To create a new SpeedTree model, users can select "File" > "New." A dialog box appears, offering the choice between starting with a blank file or utilizing a template. Templates are often optimized for specific target pipelines, such as "Games" or "VFX," providing a pre-configured starting point.11
* Open: Existing .spm files can be opened by selecting "File" > "Open" and navigating to the desired file.11
* Save: The standard "File" > "Save" command saves the current state of the model to its existing .spm file.11
Several specialized saving options enhance workflow flexibility and project management:
* Save As: Allows saving the current model under a new name or in a different location, creating a distinct copy.11
* Save As with Assets: This crucial feature saves the .spm file along with all its associated external assets, such as textures and mesh files, into a user-specified location. SpeedTree Modeler automatically updates the internal file paths within the .spm file to reference these newly co-located assets.11 This is particularly valuable for ensuring project portability, archiving, and collaboration, as it prevents broken links to dependent files.
* Save Incremental: Selecting "File" > "Save Incremental" creates a new, numbered version of the currently open and previously saved file. The saved files will have a numerical suffix appended to their original name (e.g., MyTree_001.spm, MyTree_002.spm), facilitating a simple form of version control and allowing artists to preserve different stages of their work.11
When integrating SpeedTree assets into game engines like Unity, different file extensions may be encountered depending on the Modeler version used. Unity can import .spm files created with SpeedTree Modeler 7 (specifically, files resaved using the Unity version of Modeler 7). For models created with SpeedTree Modeler 8 or 9, Unity directly imports .st or .st9 files.1 This evolution in file formats likely reflects advancements in the SpeedTree technology, particularly concerning optimizations and data structures tailored for real-time engine compatibility. The Modeler 10 manual explicitly covers "Create, open, or save files" 8, indicating these fundamental operations remain a core part of the user experience.
Section 1.5: Understanding and Managing Units and Scale
A distinctive aspect of SpeedTree Modeler is its fundamentally unitless core design.12 This means that artists are not constrained to a specific measurement system (e.g., meters, feet, centimeters) during the modeling process. If a tree is intended to be 50 feet tall, its height property would be set to 50 units within the Modeler; similarly, a height of 1500 centimeters would be entered as 1500 units. This abstract unit value is visually represented by the height ruler in the Tree Window.
This unitless approach offers flexibility, with many users opting to resize their models as needed after importing them into their target application, which may have its own defined unit system.12 However, for users who prefer to work with specific units from the outset, or need to convert existing models, SpeedTree provides several mechanisms. For new models, the default unit is set to feet.12 This scene unit setting can be modified via the Application Preferences dialog, typically found under "Edit" > "Preferences," within a "Tree Window" tab.12 If a tree saved with a different scene unit is opened, the Modeler will issue a warning, but no automatic scaling occurs, prompting the user to either adjust their current scene units or convert the model.12
To aid in visual scale assessment within this unitless environment, SpeedTree Modeler includes a "height indicator." This is an icon, typically of a person or a squirrel, displayed next to the height ruler in the scene. Its sole purpose is to provide a relatable visual cue for the tree's size relative to the chosen unit system.12 The human height indicator is consistently equivalent to 6 feet tall. Thus, if the scene units are set to feet, the indicator will be 6 units high; if set to centimeters, it will be approximately 182 units high. The squirrel indicator, representing 1 foot, appears for smaller models. This simple yet effective UI element helps ground the abstract unit system in tangible terms. It's also noteworthy that tree assets purchased from the official SpeedTree Store are typically modeled in feet.12
For converting model scales, SpeedTree Modeler offers several tools beyond simply altering individual component sizes (which can lead to inconsistencies 12):
* Scene Unit Conversion: Accessible via "Tools" > "Scene unit conversion," this option scales the entire scene by converting from the current scene unit to a target unit (e.g., feet to meters). The Modeler attempts to suggest appropriate "Convert from" and "To" units based on the current settings and the model's history.12
* Arbitrary Scene Scale: Found under "Tools" > "Arbitrary scene scale," this allows scaling the entire scene by a specified multiplication factor. An option to "Avoid size scalars" exists, which modifies world units directly but can lead to unexpected transformations if the model relies heavily on relative values.12 It is important to note that scene scaling operations can sometimes cause subtle relative movements that might slightly alter the tree's appearance; an undo function is available if the results are unsatisfactory.12
* Export Scaling: A non-destructive scaling option is available within the export dialog. This allows artists to work in one unit system within the Modeler and then convert the model's scale upon export to match the unit system of the target application. This method only affects the outgoing geometry and does not alter the source .spm file.12 For file formats that support scene units (like FBX), the exported file will either use the current scene unit or the unit specified during export conversion.
This combination of a unitless core with multiple scaling and conversion utilities provides considerable flexibility for integrating SpeedTree assets into diverse production pipelines, each potentially having different unit standards. However, it also underscores the importance of diligent unit management by the user to ensure predictable and accurate scaling across applications.
Section 1.6: Upgrading Models from Previous SpeedTree Versions
SpeedTree Modeler provides mechanisms for upgrading models created in older versions of the software to be compatible with newer features and architectural changes. The SpeedTree Modeler 10 manual includes an entry for "Upgrade old models" 3, though the specific content of this page was not accessible during research.13 However, documentation for upgrading to SpeedTree 8 4 and notes regarding version compatibility 14 offer valuable insights into the general principles and processes involved, which are likely to share conceptual similarities with upgrading to version 10.
Upgrading older models is often necessary to take advantage of new features, performance improvements, and changes in how geometry or effects (like wind and Level of Detail) are handled in more recent versions of SpeedTree.4 For example, when upgrading models from versions prior to SpeedTree 8, significant changes occurred in generator types:
* Leaf Generators: Older Leaf generators were superseded by two new types: Batched Leaf generators and Leaf Mesh generators. Batched Leaf generators offer significantly faster computation but do not allow for individual leaf node editing. Leaf Mesh generators compute more slowly but permit detailed node-level adjustments. The automatic upgrade process typically defaults to Batched Leaf generators for performance.4 Benefits of upgrading leaf systems include faster computation, easier orientation, leaf deformation capabilities (fold, curl, noise), resolution control, improved collision, and access to new seasonal systems.4
* Spine Generators: The versatile Spine generator of older versions was replaced by a more specialized set of three generators: Branch, Frond, and Cap generators. This change requires a more explicit definition of geometry types in the Generation Editor, with Frond and Cap generators typically being children of a Branch generator.4
The upgrade process itself is often facilitated by an "Upgrade" button that appears in the Generation Editor when an eligible older generator is selected.4 Pressing this button attempts to swap the old generator with its modern equivalent(s), mapping properties to approximate the original appearance. However, it is crucial to understand that upgraded models are not always exact replicas of their older counterparts. At best, they might appear as if randomized; at worst, they may require some manual editing and fine-tuning to restore them to a state closely resembling their previous appearance.4 For this reason, it is generally recommended to upgrade generators one at a time, making corrections and adjustments as needed, rather than attempting to convert an entire complex model at once.4 Some updates, like those in version 8.0.3, aimed to improve the fidelity of upgrades from specific older versions like v7.14
The necessity for such an upgrade path, and the potential for discrepancies in the converted models, underscores the significant architectural evolution between major SpeedTree versions. New features and optimizations often rely on different underlying data structures or computational methodologies that are not directly backward-compatible without a translation layer. This careful, iterative approach to upgrading ensures that users can bring legacy assets forward while minimizing disruption and allowing for artistic oversight during the transition.
________________
Part II: Deconstructing the SpeedTree Modeler User Interface
Section 2.1: Holistic UI Overview and Navigation Principles
The SpeedTree Modeler user interface (UI) is a sophisticated environment designed to provide comprehensive control over the complex process of vegetation modeling. While specific documentation pages detailing the UI overview for Modeler 10 were inaccessible 15, information from the Modeler 10 documentation map 8, a general UI description for Modeler 10 16, and UI details from earlier versions 17 allow for a thorough reconstruction of its primary components and operational philosophy.
The interface is composed of several key elements, each serving a distinct function:
* Tree Window: The primary 3D viewport for visualizing and interacting with the model.
* Generation Editor: A hierarchical editor for constructing and managing the generator network that defines the tree's structure.
* Cutout Editor: An integrated tool for creating and editing custom 2D meshes, often used for leaves and cards.
* Property Bar: Displays and allows editing of parameters for any selected object, generator, or node.
* Assets Bars: A collection of toolbars for managing various asset types, including Materials, Material Sets, Meshes, Displacements, and Masks.
* Rules Window: An interface for creating and applying Lua scripts (Rules) to customize model behavior and create advanced controls.
* Message System: Provides feedback, warnings, and error messages to the user.
* Application Preferences: A dialog for configuring global application settings.16
This modular design reflects a structured approach to managing the multifaceted task of tree creation, allowing users to focus on specific aspects of the model within dedicated interface sections. The UI is designed to be highly customizable, a common characteristic of professional Digital Content Creation (DCC) applications. Users can typically detach individual bars and windows, dock them in different arrangements, organize them into tabbed groups, and reorder tabs to suit their workflow preferences. A "Reset Layout" option is usually available to restore the interface to its default configuration.17 Additionally, visual themes, such as a default dark theme and a legacy light theme, may be offered to cater to user preference.17 This level of customization ensures that artists can tailor their workspace for optimal efficiency and comfort.
Table 2.1: SpeedTree Modeler UI Components Overview
UI Component
	Primary Function
	Key Features/Sub-components
	Tree Window
	Main 3D viewport for model visualization and direct interaction.
	Toolbar, Viewport Customization, Navigation Controls, Overlays (Gizmos, Indicators), Properties.
	Generation Editor
	Hierarchical construction and management of the model's generator network.
	Toolbar, Hierarchy View, Scene Object Icons (Forces, Collision Objects, Projectors), Icon Overlays.
	Property Bar
	Displays and allows editing of parameters for selected items.
	Dynamic Property Display, Curve Editor, Variance Editor, Group Menus (Copy/Paste), Message Pane.
	Assets Management
	Creation, importation, and management of various asset types.
	Materials Bar (Map Editor, Color Editor, UV Area Editor), Material Sets Bar, Meshes Bar, Displacement Bar, Masks Bar, Common Asset Settings.
	Cutout Editor
	In-application creation and refinement of 2D meshes, typically for foliage elements.
	Toolbar, Editing Window, Point/Pivot/Anchor Editing, Straighten Mode, Masking, Sections, LOD Output.
	Rules Window
	Interface for creating, managing, and applying Lua-based Rules for custom controls.
	Script Editor, Rule Controls Display.
	Message System
	Provides system feedback, including errors, warnings, and informational notes.
	Often integrated into Property Bar or as a separate log.
	Application Preferences Dialog
	Configuration of global, application-wide settings.
	Settings for Tree Window (e.g., units), Property Bar behavior, etc.
	Section 2.2: The Tree Window: Primary Interaction Viewport
The Tree Window is the central 3D viewport in SpeedTree Modeler, serving as the primary canvas for visualizing, editing, and interacting with the vegetation model. It is more than a passive display; it is an active workspace equipped with integrated tools and feedback mechanisms crucial for the artistic and technical aspects of tree creation.
Sub-Section 2.2.1: Tree Window Toolbar Reference
Prominently featured within the Tree Window, its toolbar provides immediate access to a wide array of common modeling operations, rendering controls, tools for managing scene objects, and post-processing functions.18 The toolbar is typically organized into logical groups:
* Mode: Allows switching between fundamental editing paradigms, such as "Generator" mode (for editing generator properties), "Node" mode (for editing individual node properties), and "Freehand" mode (for direct artistic manipulation).18
* Edit: Contains controls aiding model creation and structural editing. This includes:
   * Add: For adding new generators to the model.
   * Visibility: A suite of tools to control which parts of the model's structure are visible, facilitating easier editing of complex hierarchies. Options include hiding/unhiding selected elements, showing all, and various "Focus" modes (Focus, Focus Siblings, Focus Ancestors, Clear Focus) to isolate specific parts of the model. "Conceal" and "Expose" allow for progressive hiding or revealing of generator levels.18 These focus and concealment features are essential for managing visual complexity and can improve performance when working on dense models.20
   * Season: Accesses properties for setting seasonal variations of the model.
   * LOD (Level of Detail): Manages settings related to Level of Detail and resolution for the model.18
* Scene: Provides access to scene-level objects and global effect controls:
   * Scene Objects: Menus for managing Forces (display, add, select), Collision Objects (display, add, generate), Scene Cameras (add various camera types, including from FBX), Projectors (add different projector shapes), and Mesh Helpers (display, add, select).18
   * Wind: Offers comprehensive controls for wind animation, including editing Fan properties, enabling/disabling wind and gusting, launching the Wind Wizard for automatic setup, setting preset wind conditions (e.g., Breezy, Stormy), and managing Fan object visibility.18
   * Light: Provides access to lighting options, such as editing Light object properties, selecting preset lighting conditions (e.g., Standard, Golden Hour), setting shadow quality, and managing ambient occlusion rendering.18
* View: Controls how the model is rendered and what visual aids are displayed in the Tree Window:
   * Render: Selects the active render mode (e.g., Lit, Wireframe, Normals).
   * Show: Toggles the visibility of various geometry types (Leaves, Fronds, Branches, Zones, etc.), auxiliary data (Bones, Hints, Normals, Cages), environmental elements (Ground), and UI overlays (Text, Light Gizmo, Fan, Axis Indicator). It also includes options for selection highlighting styles and toggling the Art Director gizmo.18
   * Gizmo: Controls the behavior of the transformation gizmo used for scene objects and root-level nodes, including Translate, Rotate, Scale modes, and Global/Local space transformation. Options to orient objects to the camera's look vector are also present.18
   * Zoom: Zooms the view to the current selection or to fit the entire model if nothing is selected.18
* Post: Contains actions applied to the model after its primary computation:
   * AO (Ambient Occlusion): Computes per-vertex ambient occlusion.
   * Collision: Sets leaf collision options with varying quality levels (None, Low, Medium, High), including options for cluster plane overlap prevention and spherical tests for leaves.18
   * Shade: Enables pruning of leaves based on their relative shade level.
   * Collapse: Toggles the display of icon names on the toolbar itself, useful for saving space on smaller displays.18
Sub-Section 2.2.2: Customizing the Viewport
While the specific Modeler 10 documentation page for viewport customization was inaccessible 22, functionality from earlier versions 20 indicates that users can typically tailor the Tree Window's layout and appearance. This often includes options to switch between a single perspective viewport and multiple viewports (e.g., a four-view layout showing perspective, top, front, and side orthographic views). Such layouts are commonly accessed via a right-click context menu within the viewport or through toolbar options.20 Users may also be able to set a background image for reference purposes and define a "screenshot safe frame" to delineate the area captured by image export functions.23
Sub-Section 2.2.3: Tree Window Navigation
Navigating the 3D space of the Tree Window is fundamental to the modeling process. Although the dedicated Modeler 10 page was unavailable 24, earlier versions describe robust navigation schemes.20 Typically, two main navigation types are offered:
* Standard Navigation: This mode usually involves orbiting the view around a focal point (e.g., by dragging with the left mouse button), panning the view (e.g., middle mouse button), and zooming (e.g., mouse wheel or combination of mouse buttons). The up-vector is generally maintained in this mode.23
* Traveller Navigation: This offers a first-person style of navigation, where movements simulate walking through the scene, with controls for forward/backward movement, rotation, panning, and free-look.23
These navigation controls allow artists to inspect their models from any angle and distance, crucial for assessing form, detail, and overall composition.
Sub-Section 2.2.4: Overlays (Gizmos and Indicators)
Tree Window overlays are visual tools designed to enhance the workflow by making certain editing parameters and scene information more accessible and directly manipulable within the 3D view.25 These overlays can typically be toggled via the "Show" > "Overlay" menu in the Tree Window toolbar. Key overlays include:
* Axis Indicator (A): Displays the world X, Y, and Z axes from the current camera's perspective, helping users orient themselves in 3D space.25
* Light Gizmo (B): A visual representation of the primary directional light source, showing its rotation, color, and intensity. It often allows for direct manipulation of the light's direction.20
* Fan (C): A gizmo representing the wind source, containing properties for the active wind algorithm. It can provide visual feedback on wind direction and strength.25
* Wind Indicator (D): Displays the current strength of the wind affecting the scene.25
* LOD Indicator (E): A visual control and indicator for the current Level of Detail being displayed for the model. It may allow manual scrubbing through LOD states or reflect automatic LOD changes based on camera distance.20
These overlays provide immediate visual feedback and often direct control over critical scene parameters, streamlining the process of lighting, animating, and optimizing the tree model.
Sub-Section 2.2.5: Tree Window Properties
The Tree Window itself possesses a set of properties that control its rendering behavior and the appearance of various visual aids. While the Modeler 10 specific page was inaccessible 26, documentation for SpeedTree 7 23 lists several categories of such properties, which often persist in similar forms in later versions:
* General Rendering: Options like "Use Shaders" (to enable/disable OpenGL shaders for rendering) and "Transparency" settings.
* Selection Highlighting: Controls how selected objects are visually distinguished in the viewport.
* 3D Icon Scale: Adjusts the size of icons for scene objects like Forces.
* Hand Drawing: Properties related to hand drawing, such as "Spacing Style" (relative or absolute units for control point distance).
* Manipulator: Settings for the transformation manipulator (gizmo), including its mode (Translate, Rotate, Scale) and size. It's important to note that this manipulator typically affects scene objects (Forces, Lights, etc.), not the tree components themselves, which are edited via node editing or generator properties.23
* Viewport: Settings for background images and styles (e.g., "Full Frame").
* Screenshot Safe Frame: Controls for displaying a frame indicating the region for image exports.
* Perspective Camera: Parameters for the perspective camera, such as navigation type (Standard, Traveller) and field of view.
These properties allow users to customize the visual environment of the Tree Window to suit their preferences and specific task requirements.
Section 2.3: The Generation Editor: Hierarchical Model Construction
The Generation Editor is a cornerstone of the SpeedTree modeling workflow, serving as the primary interface for constructing and managing the hierarchical structure of a tree model at its highest conceptual level.27 It provides a visual representation of the entire generator network, allowing users to add, link, and manage the various generators that define the tree's components and their relationships.
Sub-Section 2.3.1: Generation Editor Overview
This editor window displays all generators currently in use for a model. Its interface typically comprises:
* A: The Generation Editor Toolbar: Contains options for editing the model on a broad scale, managing generators, and controlling the layout and information displayed within the hierarchy view.27
* B: The Hierarchy View: This is the main area, displaying a hierarchical tree diagram of every generator in the model, illustrating their parent-child relationships. Users can select generators here to edit their properties or drag and drop generator icons to re-parent them and thus alter the model's structure.27
* C: Scene Object Icons: Provides access to add and edit scene-level objects such as Forces, Collision Objects, and Projectors, which can interact with or influence the generated tree.27
The fundamental principle is that generators represent the anatomical components of the model (trunk, branches, roots, fronds, leaves, etc.). The overall structure of the model is explicitly defined by how these generators are linked together in the hierarchy. Each generator can have one parent and multiple children, mirroring the branching patterns found in nature.27 This hierarchical organization is central to SpeedTree's procedural power, allowing complex forms to emerge from interconnected rule sets.
Sub-Section 2.3.2: Generator Hierarchy and Icon Overlays
To provide users with at-a-glance information about the state and properties of generators and their links, the Generation Editor employs a system of icon overlays. These context-sensitive visual cues appear on or near the generator icons in the hierarchy view.27 Common overlays include:
* A: Node Count: Indicates the number of nodes (e.g., individual branches or leaves) being created by that specific generator link.
* B: Hand Drawing Icon: Signifies that the generator's output is being created or has been converted to the "Hand Drawing" mode, allowing for direct artistic sculpting of its path.
* C: Selection Tag: Appears when a scene object (like a Force) that affects or is related to the generator is currently selected in the scene.
* D: Blue Highlight: Often indicates that the generator is under the influence of "Shape Control," where its growth is being guided towards a defined shape.
* E: Message Icon: Signals that there are one or more errors, warnings, or informational notes associated with this generator. These messages can be viewed by selecting the generator and accessing the message pane in the Property Bar.
* F: Hidden Generators: Generators that are currently hidden from view (but may still compute if their children are visible) are typically grayed out or visually subdued.
* G: Inactive Icon: Indicates that the generator is currently inactive or not visible at the current resolution setting. This can be controlled via properties like "Generation:Common:Active".27
These overlays serve as a critical diagnostic and status display, enabling users to quickly understand the state of complex generator networks without needing to constantly inspect individual properties.
Sub-Section 2.3.3: Generation Editor Toolbar Reference
While the specific toolbar reference for Modeler 10's Generation Editor was not accessible 28, documentation for SpeedTree 9 29 provides a comprehensive list of functions typically found in this toolbar, which are likely to have counterparts in version 10. These tools are crucial for managing generators, controlling the display, and performing batch operations. The toolbar is generally divided into groups like "Actions" and "Options":
* Actions Group:
   * Add Geometry to Selected: Adds a new child generator to the currently selected generator.
   * Save Selected as Template: Allows users to save a selected generator or a sub-hierarchy as a reusable template.
   * Make Geometry Force from Selected: Creates a new Geometry Force object using the geometry produced by the selected generator(s).
   * Geometry Force Actions: Menus to add selected generators to, remove them from, or replace existing generators within a Geometry Force.
   * Hand Drawing Options: Contextual tools for hand-drawn branches, such as clearing hand-drawn nodes, setting a generator as the target for new hand-drawn elements, locking a generator against hand drawing, and converting procedural branches to hand-drawn.
   * Toggle Visibility: Shows or hides the selected generators.
   * Clear Node Edits: Removes all individual node edits from the nodes produced by the selected generator.
   * Select Nodes with Edits: Selects all nodes within the chosen generator(s) that have had manual edits applied and switches to Node editing mode.
   * Clear Freehand Edits: Removes edits made using Freehand modeling tools.
   * Randomize Selected: Applies new random seed values to the selected generators, altering their output if variance is used in their properties.
   * Variance: Opens an editor or provides access to edit all variance values applied on the selected generator.29
* Options Group:
   * Zoom All: Adjusts the view to display all generators within the Generation Editor window.
   * Layout Generators: Automatically rearranges the generator icons and links in an orderly fashion.
   * Style: Allows choosing different visual styles for the generator layout (e.g., "Standard," "Compact").
   * Orientation: Sets the direction of the hierarchy layout (e.g., "Portrait" for vertical, "Landscape" for horizontal, "Automatic").
   * Make All Generator Names Unique: Assigns unique numerical suffixes to generators that share the same name.
   * Paste: Pastes a copied generator or hierarchy into the editor.
   * Name Display: Options to show all generator names, only selected names, or no names.
   * Statistics Display: Controls the display of compute time information (No statistics, Total time per generator, Average time per node) or polygon counts per generator, aiding in performance diagnosis.
   * Revert All to Saved: Discards all unsaved changes made to generator properties since the last save.29
This toolbar provides a powerful set of commands for efficiently managing and analyzing the procedural backbone of the SpeedTree model.
Section 2.4: The Property Bar: Parameter Control Hub
The Property Bar is a critical UI component in SpeedTree Modeler, serving as the central hub for viewing and modifying the parameters of any selected object, whether it's a generator, an individual node, a scene object like a Light or Force, or even the Tree Window itself. Although direct documentation for the Modeler 10 Property Bar was not available 30, extensive descriptions from earlier versions (SpeedTree 7, 8, and 9) 31 provide a clear understanding of its functionality, which is expected to be largely consistent in version 10.
When an item is selected, its editable properties are displayed in the Property Bar. If multiple items are selected, the Property Bar shows only those properties that are common among all selected items; any edits made in this state will apply to all items in the selection.33
Navigating the Property Bar, especially when dealing with objects that have numerous properties, is facilitated by several means:
* Scrolling: A standard scroll bar or the mouse scroll wheel can be used to move through the list of properties.33
* Group Headers: Major property groups often "stack" as clickable buttons or headers at the top or bottom of the bar. Clicking a group header scrolls the view directly to that group of properties.33 The behavior of these group headers (e.g., whether they expand/collapse or simply navigate) can sometimes be configured in Application Preferences.32
* Tabs: For many selectable objects, particularly generators, the Property Bar may display tabs at the top. These tabs organize related properties into logical sets (e.g., "Spine," "Skin," "Generation"). Clicking a tab filters the Property Bar to show only the properties within that specific group, aiding focus. An "All" tab is typically present to revert to showing all available properties.21
Each major property group often features a menu button (usually an arrow icon) on its right side. This menu typically provides options such as:
* Copy: Copies the values of all properties within that group.
* Paste: Pastes previously copied group values into the same property group of another compatible object (even across different models).
* Help: Opens the relevant section of the SpeedTree documentation for that specific property group in a web browser.33
A Message Pane is often located at the top of the Property Bar. This pane lists any errors, warnings, or informational messages that were generated by the selected object during the tree computation process. While normally collapsed, it can be opened manually and will often open automatically if errors or warnings occur.33
Properties themselves can be of various types: numerical values (integers or floating-point numbers), combo boxes (drop-down lists), color pickers, text strings, and booleans (checkboxes). Numerical properties may be displayed with sliders (if their range is clamped) or thumbwheel-style spinners for quick editing.32 Importantly, many properties can also be controlled by Curves (editable in the Curve Editor) or have associated Variances (editable in the Variance Editor) to introduce randomization.33
A fundamental aspect of the Property Bar is its differing behavior in Generator Mode versus Node Editing Mode.32
* In Generator Mode (when a generator is selected), the properties display their base values, variances, and any applicable curves (Parent Curves, Profile Curves, etc.). Edits here affect all nodes produced by that generator.
* In Node Editing Mode (when an individual node is selected), the properties display offset values. These offsets are added to the values calculated by the node's parent generator. This allows for specific, art-directed tweaks to individual tree components without altering the underlying procedural rules of the generator.32 Property names in Node mode often appear in a distinct color (e.g., orange) to indicate they are offsets.9
This dual-mode behavior is central to SpeedTree's hybrid modeling approach, enabling both broad, rule-based control and fine-grained artistic adjustments.
Sub-Section 2.4.1: Curve Editor
The Curve Editor is an indispensable tool in SpeedTree Modeler, providing a visual interface for editing the various curves that control property behaviors. While the Modeler 10 specific page for the Curve Editor was inaccessible 36, documentation for SpeedTree 9 37 offers a detailed look at its features, and the Modeler 10 documentation map confirms its presence and importance.38
The Curve Editor typically appears when a user clicks on a curve icon associated with a property in the Property Bar. It is an interactive window that presents a detailed view of the curve and provides tools for shaping it. Key components of the Curve Editor include:
* Toolbar:
   * Parent Level: A drop-down menu allowing selection of the curve associated with different parent levels for the current property (relevant for Parent Curves).
   * Curve Preset: A drop-down list of commonly used curve shapes (e.g., linear, ease-in, ease-out, bell curve) that can be quickly applied as a starting point.
   * X / Y Coordinate Input: Displays the coordinates of a selected point on the curve and allows for precise numerical input. The X-axis generally ranges from 0 to 1, representing normalized position (e.g., along a parent branch or down a node's length). The Y-axis represents the multiplier for the property's value.
   * Pin: A toggle to keep the Curve Editor window open even when clicking outside of it, useful for making iterative adjustments while observing changes in the Tree Window.37
* Curve Window: The main area where the curve is displayed and manipulated.
   * Editing Points: Green points on the curve can be clicked and dragged to change its shape. Multiple points can be selected (e.g., using CTRL-click or by dragging a selection box).
   * Adding Points: New points can usually be added by double-clicking on the curve line.
   * Deleting Points: Selected points can be deleted (e.g., using the Delete key).
   * Bézier Handles: Double-clicking an existing point often converts it to a Bézier point, revealing handles that allow for smooth, tangential control over the curve's curvature. Double-clicking again may revert it to a standard point.37
The curve itself is typically drawn within a lighter gray area representing the normal operational range (e.g., Y-values from 0 to the property's maximum). While curves can sometimes be edited to exceed this range, it is generally not recommended as it can lead to unpredictable model behavior.37 The extensive use of curves for property control is a hallmark of SpeedTree's expressive power, allowing artists to define sophisticated relationships, transitions, and distributions that contribute significantly to the organic appearance of the models.
Sub-Section 2.4.2: Variance Editor
Variance is a key mechanism in SpeedTree for introducing controlled randomness and natural-looking irregularities into procedurally generated models. While a specific Modeler 10 page for the Variance Editor was inaccessible 39, its function is described in conjunction with the Property Bar in earlier versions.31
Many numerical properties in SpeedTree have an associated variance value. This value defines a range around the property's base value from which a random number will be chosen for each node instance created by a generator.32 For example, if a "Branch Length" property has a base value of 10.0 and a variance of 2.0, individual branches generated might have lengths randomly distributed between 8.0 (10.0 - 2.0) and 12.0 (10.0 + 2.0).
In the Property Bar, the variance for a property is often indicated by a small numerical button or a "+/-" icon next to the main value field. Clicking this button typically toggles the Property Bar into a variance editing mode, where the input fields now accept the variance amount rather than the base value. A "#" icon might then appear to switch back to base value editing.32 Although a dedicated "Variance Editor" window isn't explicitly detailed in the snippets beyond this mode switch within the Property Bar, this mechanism allows artists to precisely control the degree of randomness applied to most aspects of the tree, contributing to its organic and non-uniform appearance.
Section 2.5: Asset Management: Materials, Meshes, Displacements, Masks
SpeedTree Modeler relies on a variety of external and internal assets to construct detailed vegetation models. These assets include materials that define surface appearances, meshes for custom geometry or foliage cards, displacement maps for adding surface detail, and masks for controlling generation areas. The Modeler provides dedicated interface elements—typically a series of tabbed bars—for creating, importing, and managing these assets. While comprehensive documentation for the Modeler 10 asset system was largely inaccessible 40, the Modeler 10 documentation map 8 outlines the structure, and details from earlier versions 10 provide substantial information on their likely functions. The granular nature of this asset system promotes a modular and reusable workflow, allowing artists to build and leverage libraries of these components.
Sub-Section 2.5.1: Common Asset Settings
Across the various asset bars (Materials, Meshes, etc.), there are common operations for managing the assets themselves. While the specific "Common asset settings" page for Modeler 10 was inaccessible 46, documentation for the Meshes Bar in SpeedTree 9 44 indicates that processes for adding new assets (e.g., by clicking a "+" button), removing assets, renaming them, reordering them within the list, and applying them to parts of the tree are generally consistent. This implies a standardized approach to asset lifecycle management within the Modeler UI.
Sub-Section 2.5.2: Materials Bar (and associated editors: Map Editor, Color Editor, UV Area Editor)
The Materials Bar is the interface for defining and managing material assets, which dictate how light interacts with the surfaces of the tree model. Although the Modeler 10 Materials Bar page was not directly accessible 47, its structure, including sub-editors, is listed in the Modeler 10 documentation map 8 and in SpeedTree 9 documentation.10
Materials in SpeedTree, particularly since version 8, are designed around Physically Based Rendering (PBR) principles.48 The Materials Bar allows users to assign various texture maps that drive the PBR calculations. These maps are typically managed via a Map Editor.8 Key PBR maps, as detailed for SpeedTree 9 45, include:
* Color (Albedo): Defines the intrinsic base color of the material.
* Normal: A tangent-space normal map providing fine surface detail.
* Glossiness (or Roughness): Controls the microsurface detail, affecting the sharpness and spread of specular reflections.
* Specular: Scales the amount of light reflected (for non-metals).
* Metallic: Defines whether a surface is metallic (1) or non-metallic (0).
* Subsurface Color & Amount: Control light transmission through thin materials like leaves.
* Ambient Occlusion (AO) Map: Provides pre-baked micro-occlusion details.
* Custom Map: A user-definable map for custom shader effects.
In addition to the Map Editor, the Materials Bar may also integrate a Color Editor for adjusting base colors or tinting effects, and a UV Area Editor for managing UV coordinates or specific UV manipulations related to the material.8 The tight integration of these editors within the Materials Bar streamlines the material authoring process.
Sub-Section 2.5.3: Material Sets Bar
The Material Sets Bar is listed as a component of the UI in both Modeler 10 8 and SpeedTree 9.10 While its exact functionality in version 10 is not detailed in the available snippets, glossary information from SpeedTree 7 49 for a similar term ("Color Set") suggests that Material Sets might be used to house rendering state information separate from the texture information contained in a material asset. The purpose of this separation was historically to help manage draw calls in the SpeedTree SDK, as materials sharing the same Color Set (Material Set) could potentially be batched for more efficient rendering. This implies a role in rendering optimization or managing material variations.
Sub-Section 2.5.4: Meshes Bar
The Meshes Bar is dedicated to importing, creating, and managing 3D mesh assets used within SpeedTree models. These can range from custom-modeled trunks and branches to individual leaf cards or complex frond structures. Documentation from SpeedTree 9 44 and earlier versions 42 provides a comprehensive overview of its capabilities:
* Importing Meshes: The Modeler supports importing meshes in various formats, commonly including FBX and OBJ.42
* Mesh LODs: Users can import or define different versions of a mesh for High, Medium, and Low Levels of Detail (LODs). The appropriate mesh is then used based on the tree's LOD settings or Resolution settings.44 An option to link to an additional mesh asset can provide even more LOD stages.44
* Transform Properties:
   * Orientation: Allows correcting the initial orientation of imported meshes to match SpeedTree's coordinate system (e.g., Y-up or Z-up).42
   * Flip: Options to invert one or more axes of the mesh if it imports incorrectly.42
   * Flip Normals: Reverses the direction of vertex normals.42
   * Match Winding: Corrects triangle winding order if face normals differ from vertex normals.42
* Wind Direction (for Leaves): Specific properties for meshes used as leaves, such as defining a "Growth" vector and "Ripple" style, which influence their behavior with wind animation.42
* Scale: A scale value can be applied to meshes, often computed based on how much of a texture map the mesh covers.44
* Cutout Editor Integration: An "Edit" button in the Meshes Bar typically launches the Cutout Editor, allowing users to create or modify a mesh directly within SpeedTree, often based on a material's texture.44 This is particularly useful for creating optimized leaf/card meshes.
* Collections: An advanced feature where parts of the currently computed tree can be captured as a new mesh asset (a "collection"). This collection can then be used elsewhere on the tree or as part of a mesh force.42
* Embedding: Meshes can be embedded directly into the SpeedTree model file (.spm), so they no longer need to be read from an external disk file.42
Sub-Section 2.5.5: Displacement Bar
The Displacement Bar manages displacement assets, which are used to add per-vertex translation to geometry, creating surface details like bumps, ridges, or other irregularities.49 This displacement can be driven by procedural noise patterns or by image-based maps loaded as displacement assets. This is a common technique for enhancing the realism of branch surfaces or adding texture to trunks without requiring extremely high-resolution base meshes. The Displacement Bar would allow for the creation, importation, and assignment of these displacement effects.
Sub-Section 2.5.6: Masks Bar
The Masks Bar is used to create and manage mask assets. A mask, in SpeedTree, acts as a restriction on the area where geometry or other elements can be generated.49 Masks can be defined based on various criteria, such as positional constraints within the 3D scene, specific texture coordinate (UV) regions, or directly from an image file where grayscale values determine the masked areas. These are powerful tools for controlling the distribution of elements like leaves, branches, or decals with a high degree of spatial precision.
Section 2.6: The Cutout Editor: In-App Mesh Creation and Refinement
The Cutout Editor is an integrated 2D mesh editing tool within SpeedTree Modeler, designed to empower users to create and refine custom polygonal meshes, primarily for use with materials, without needing to switch to external 3D modeling software.51 This tool is particularly valuable for generating optimized geometry for elements like leaves, petals, frond sections, or any texture-mapped planar or near-planar surface. It offers a balance between achieving high visual detail and creating efficient meshes suitable for real-time game assets.
The Cutout Editor can be accessed by clicking an "Edit" button associated with a mesh asset in the Meshes Bar, or often via a shortcut from a material asset if a mesh is already applied or a new one is intended for that material.51 Its interface typically includes:
* A: Toolbar: Contains high-level controls and tools for editing the cutout mesh.
* B: Editing Window: The 2D canvas where the cutout's geometry is displayed against its associated material's texture, and where direct manipulation occurs.
* C: Vertex and Face Count: A live display of the current mesh's complexity.
* D: LOD Selector: Allows users to create and save different versions of the cutout mesh for High, Medium, and Low Levels of Detail (LODs) or for different Resolution settings.51
Key functionalities of the Cutout Editor include:
* Point Editing: Users can add, move, and delete vertices (points) that define the mesh outline. The editor automatically triangulates the area enclosed by these points. If the associated material has an opacity channel (alpha map), any triangles that fall into completely transparent regions of the texture are often automatically removed, leading to a tighter, more optimized mesh.51
* Pivot Point: A special, non-deletable white point within the mesh defines its origin or pivot. This point can be moved to control how the mesh is anchored or rotates when placed on the tree. Consistency of the pivot point across different LOD versions of the same cutout can be maintained using options like "Copy pivot from High".51
* Straighten Mode: This is a specialized and powerful feature designed to help work with textures derived from photogrammetry or other sources where curvature or perspective distortion might be present in the source image. Straighten Mode allows the user to define a deformable UV space over the texture. By manipulating control points, this space can be "unwarped" to remove perceived curvature from the texture area being meshed. Meshes created within this straightened UV area tend to deform more predictably and naturally when applied procedurally to the tree. Controls allow moving, rotating, and deforming the straighten area, as well as adjusting its width. It is often used in conjunction with a "Mirror" option for symmetrical cutouts. The straighten position can also be copied across LOD levels. This mode also serves as a focus tool for working on small sections of large texture atlases. UV warning indicators can highlight areas where texture deformation might be inaccurately represented due to insufficient mesh points, prompting the user to add more detail.51 This feature directly addresses a common challenge in modern asset creation workflows that rely on scanned textures.
* Anchors: The Cutout Editor allows for the placement and editing of "mesh anchors." These are specific points on the cutout mesh that define precise locations and orientations for child elements (e.g., smaller branches or fruits growing from a leaf cluster mesh) to attach. Each anchor has a position and a growth direction (often visualized by a connected dot that can be dragged). Anchors can also have an ID, which can be used by generators to spawn specific types of children at those points.51 Mesh anchors are particularly critical for low-poly modeling, enabling the creation of visually dense foliage from simplified base meshes.43
* Masks: Users can paint a mask directly within the Cutout Editor to manually remove unwanted triangles from the mesh, further refining its shape beyond automatic alpha-based culling.51
* Sections: This feature allows for the identification and delineation of subsections within a Frond mesh. These defined sections can then be manipulated individually using "Section Variance" properties in the Frond generator, allowing for more complex and varied frond deformations.51
* LOD Output: Once a cutout mesh is finalized, it can be saved to the corresponding mesh asset at different LOD levels (High, Medium, Low) using the LOD selector. The "High" level is typically used for the primary mesh data, while "Medium" and "Low" store progressively simpler versions for LOD transitions or lower resolution exports.51
The Cutout Editor's comprehensive toolset streamlines the creation of efficient, texture-aligned geometry, significantly reducing the need for round-tripping to external applications for these common tasks.
Section 2.7: Specialized Windows: Rules, Messages, Preferences
Beyond the primary modeling and asset management interfaces, SpeedTree Modeler includes several specialized windows that provide advanced customization, feedback, and global configuration capabilities.
Sub-Section 2.7.1: Rules Window
The Rules Window is the interface for working with SpeedTree Rules, which are Lua scripts designed to create custom user controls and automate complex model manipulations.16 This powerful feature allows users to extend the Modeler's default capabilities by designing simple UIs (sliders, checkboxes, etc.) that can drive multiple existing model properties in sophisticated ways. The Rules Window is where these scripts are composed, edited, and applied. (A detailed exploration of Rules scripting is provided in Part VII of this report). The existence of this dedicated scripting environment elevates SpeedTree Modeler beyond a conventional modeling tool, offering a platform for technical artists and pipeline developers to create highly customized workflows and intelligent, adaptable assets.
Sub-Section 2.7.2: Message System
The Message System is SpeedTree Modeler's primary mechanism for providing feedback to the user regarding the model building process. It communicates information about errors that may have occurred, warnings about potential issues, and general informational notes.16 These messages can appear in a dedicated message pane, often located at the top of the Property Bar when an object is selected 31, or as icon overlays on generators in the Generation Editor.27 This system is crucial for debugging in a complex procedural environment where the cause of an unexpected result might not be immediately apparent. Clear error and warning messages help users identify and resolve problems efficiently, such as conflicting property settings, missing assets, or computational issues.
Sub-Section 2.7.3: Application Preferences Dialog Reference
The Application Preferences dialog allows users to configure application-wide settings that affect the overall behavior and appearance of SpeedTree Modeler.16 Examples of settings that can typically be found here include:
* Scene Unit Configuration: As mentioned in Section 1.5, the default scene units and behavior when opening files with different unit settings can be managed here, often under a "Tree Window" tab.12
* Property Bar Behavior: Options to control aspects of the Property Bar, such as whether scrolling animates smoothly or if property group headers stack or behave as expanding/collapsing sections.32
* Other global settings: May include preferences for file handling, UI themes, memory allocation, or other system-level parameters.
This dialog provides a centralized location for users to customize the Modeler to their specific needs and system capabilities.
________________
Part III: Foundational Modeling Concepts
The creation of realistic and complex vegetation in SpeedTree Modeler is built upon a set of core concepts that govern how models are structured, generated, and controlled. Understanding these foundations—generators, nodes, properties, and curves—is essential for leveraging the full power of the software.
Section 3.1: Generators: The DNA of SpeedTree Models
Generators are the fundamental building blocks in SpeedTree Modeler, acting as the procedural "DNA" that defines the growth and characteristics of every component in a tree model.5 They are essentially rule sets that dictate how specific parts of the tree, such as trunks, branches, leaves, fronds, or roots, are formed and distributed. While the introductory documentation for generators in Modeler 10 was not directly accessible 52, their central role is well-established in the SpeedTree paradigm and outlined in the Modeler 10 documentation map.8
Sub-Section 3.1.1: Introduction to Generators
A SpeedTree model is constructed as a hierarchy of these generators, visually represented and managed in the Generation Editor.27 Each generator in this hierarchy (except for the root "Tree" generator) is typically a child of another generator, inheriting context and position from its parent. For instance, a "Branch" generator might be a child of a "Trunk" generator, and "Leaf" generators might be children of that "Branch" generator. This hierarchical linking directly defines the anatomical structure of the model.27 A single generator, based on its properties, can be responsible for creating many individual geometric instances, which are referred to as "nodes".5
Sub-Section 3.1.2: Managing Generators
The Generation Editor is the primary interface for managing generators.53 Key operations include:
* Adding a Generator: New generators can be added to the model via the "Add" menu in the Generation Editor toolbar or the Tree Window toolbar. If a generator is already selected when a new one is added, the new generator typically becomes a child of the selected one and is automatically linked. If no generator is selected, the new generator often becomes a child of the root "Tree" generator by default.
* Duplicating a Generator: Existing generators can be duplicated (e.g., by selecting their icon in the Generation Editor and choosing "Actions" > "Duplicate," or via copy-paste). Duplicated generators are not automatically part of the active hierarchy until they are linked to another generator that traces back to the Tree generator.
* Linking a Generator: The parent-child relationships between generators are established by linking them. This is usually done by dragging and dropping one generator icon onto another within the Generation Editor. This action typically creates a new link and deletes any pre-existing link for the child generator. Links themselves can often be selected and deleted.
* Deleting a Generator: Generators can be removed from the model by selecting their icon and deleting them (e.g., via a right-click context menu option "Delete").
* The Tree Generator: This is a special root generator that is always present in every model. It cannot be deleted or moved and serves as the ultimate parent in the hierarchy. It also houses many global properties that affect the entire model.53
Sub-Section 3.1.3: Generator Types and Their Specific Properties
SpeedTree Modeler offers a diverse array of specialized generator types, each designed to create a specific kind of geometry or effect. The Modeler 10 documentation map 8 lists an extensive range of these types, highlighting the software's deep focus on vegetation modeling. While the specific Modeler 10 documentation pages detailing all generator types and their comprehensive properties were largely inaccessible 54, the list itself and available information for some individual generators or properties from older versions provide a strong indication of their capabilities.
The sheer variety of these generator types, such as "Phyllotaxy" for leaf arrangements, "Bifurcation" for natural branching splits, dedicated "Frond" and "Vine" generators, underscores SpeedTree's specialization. This allows for more intuitive and powerful control over botanical structures than could be achieved with generic modeling tools.
Common generator types listed for Modeler 10 8 include:
* Core Structure: Tree, Branch, Spine
* Foliage & Details: Leaf Mesh, Batched Leaf, Leaf, Frond, Card, Cap, Decal, Fin, Knot, Shell
* Growth Control & Placement: Zone, Vine, Base, Reference, Target
* Mesh Operations: Mesh, Mesh Converter, Mesh Detail, Stitch
* Abstract/Utility: Subdivision, Cage, Proxy
Each generator type possesses a unique set of properties that control its behavior. While specific property lists for Modeler 10 are often unavailable, documentation for earlier versions (e.g., SpeedTree 8 and 9) provides insight into common property groups and their functions. For instance, Frond generator properties from v9 and v8 56 include controls for Geometry, Material assignment, Mesh LOD, Deformation (Gravity, Fold, Curl), Forces, Unification (how fronds blend or orient relative to ancestors), Collision, and Vertex Colors. Batched Leaf generator properties from v8 58 cover Generation parameters, Forces, Geometry (mesh assignment, size, orientation), Collision, LOD, Lighting, and Vertex Colors. Zone generator properties from v9 and v7/v8 59 include settings for Forces, Placement (radius, distance, angle), Mesh assignment (if not a simple disk), Growth parameters for children, LOD, and Lightmap weighting.
A critical set of properties common to many geometry-producing generators falls under the Generation group. As detailed for SpeedTree 9 61, this group is paramount as it dictates the fundamental logic of how and where child components are created and distributed. Key properties within this group often include:
* Mode: Selects the algorithm for node distribution (e.g., Classic, Proportional, Proportional Steps, Absolute, Absolute Steps, Phyllotaxy, Interval, Bifurcation, Flood, Parent). The choice of mode dramatically alters the resulting structure.
* Boundaries: Defines the zone on the parent where children can grow (e.g., "First" and "Last" as percentages of parent length, or Min/Max distance from parent ends).
* Orientation: Controls the initial angle and rotation of generated nodes relative to their parent (e.g., Spread, Alignment, various rotation axes).
* Forces: Enables or disables the influence of scene Forces on the nodes created by this generator, often with per-force multipliers.
* LOD (Level of Detail): Properties to control how the generator's output behaves during LOD transitions (e.g., "Keep" to determine survival chance, "Knockout" to cull based on LOD).
* Collision: Parameters related to how the generated nodes participate in collision detection or avoidance.
* Common Shared Properties:
   * Active: Often a curve controlled by Resolution, determining if the generator is active at different resolution states. This allows for swapping entire generation strategies for VFX optimization.61
   * Seed: A random seed value that drives any randomization within the generator's properties. Changing the seed produces a new variation.
   * Extensions: Controls how nodes are generated at the tips or breaks of parent branches.
   * Click Place: Configures the generator for use with the "Click Place" freehand modeling tool.
   * Force Containers: Determines how the generator interacts with Force objects acting as inclusion or exclusion zones.
   * Mesh Alignment: For generators growing on mesh surfaces, controls alignment to surface properties (tangent, binormal) or parent/world axes.
The depth and specificity of these generator types and their associated properties allow artists to exercise fine-grained control over nearly every aspect of vegetation morphology.
Table 3.1: Core Generator Types and Primary Functions (SpeedTree Modeler 10)
(Purpose based on name and general SpeedTree knowledge; specific Modeler 10 properties often inaccessible)


Generator Type
	Primary Purpose/Description
	Key Distinguishing Properties (Conceptual)
	Typical Use Cases
	Tree
	Root generator for the entire model; houses global tree properties.
	Scene scale, global wind settings, LOD enabling, season controls.
	Every SpeedTree model starts with this.
	Branch
	Creates primary and secondary structural elements like trunks, boughs, branches, and roots.
	Length, radius, segmentation, deformation (bend, twist), skinning properties, generation modes for children.
	Trunks, limbs, major branches, roots. 63
	Leaf Mesh
	Places individual 2D or 3D mesh instances, typically for leaves or flowers, allowing node edits.
	Mesh assignment, material, size, orientation, deformation, collision.
	Detailed hero leaves, flower petals, complex small features requiring fine-tuning.
	Batched Leaf
	Places large quantities of optimized 2D or 3D mesh instances, no individual node editing.
	Similar to Leaf Mesh but optimized for performance; parameters control the batch as a whole.
	General foliage, distant leaves, situations requiring high leaf counts. 58
	Frond
	Creates geometry that conforms to a parent spine, often using a mesh asset.
	Mesh assignment, material, width, length segments, deformation along spine (curl, fold), section control.
	Palm fronds, ferns, complex leaves with a central rachis. 56
	Zone
	Defines an area (disk or mesh surface) from which other generators can spawn nodes.
	Shape (disk/mesh), radius/size, placement rules for children, surface adhesion for mesh zones.
	Ground cover, epiphytes growing on trunks, defining areas for rock placement. 59
	Vine
	Generates vine-like structures that can grow along surfaces or follow guides.
	Pathfinding, adhesion properties, thickness, leaf/tendril generation along vine.
	Ivy, lianas, climbing plants. Modeler 10 features physics-based vines. 2
	Card
	Generates simple planar geometry, often used for billboards or very low-poly foliage.
	Material assignment, dimensions, orientation (e.g., camera-facing).
	LOD billboards, distant foliage impostors.
	Cap
	Creates geometry to cap the ends of branches or trunks.
	Material, mesh assignment, size relative to parent end.
	Sealing open branch tips, creating bud-like structures.
	Mesh Converter
	Converts imported photogrammetry scan meshes into procedural SpeedTree geometry.
	Input mesh, conversion settings, feature detection.
	Integrating scanned trunks/branches into a procedural workflow. 2
	Spine (Conceptual)
	Generic generator for creating linear elements; largely superseded by more specific types.
	Length, segmentation, orientation. (More common in older versions, functionality now in Branch/Frond etc.)
	Basic linear structures.
	Section 3.2: Nodes: The Instantiated Geometry
Within the SpeedTree procedural framework, "nodes" are the individual geometric components that are actually created and instanced by the generators.9 For example, if a "Branch" generator is configured to produce ten branches, each of those ten individual branches is a distinct node. Similarly, a "Leaf Mesh" generator might create hundreds of leaf nodes. Every visible piece of geometry in a SpeedTree model is ultimately a node.
A key aspect of SpeedTree's power lies in the ability to directly edit these individual nodes, providing a layer of artistic control on top of the procedural generation. This capability is what makes SpeedTree models "art-directable," allowing artists to move beyond purely algorithmic results and inject specific, deliberate modifications.6
To edit nodes, the Modeler must be switched into "Node" editing mode. This is typically done via a button on the Tree Window toolbar or by using a hotkey such as the TAB key.9 Once in Node mode, clicking on a component in the Tree Window selects that individual node, and the Property Bar will then display the properties specifically for that node, rather than for its parent generator. Property names in Node mode are often displayed in a distinct color (e.g., orange) to visually differentiate them from generator properties.9
Crucially, property edits made to nodes are treated as offsets to the values that were initially calculated by the generator.5 This non-destructive approach means that an artist can make a specific tweak—for instance, making one particular branch longer by editing its node's length property—and this change will persist even if the artist later globally adjusts the length property on the parent generator. The individually edited branch will retain its offset and remain relatively longer. When a node is selected for editing for the first time, its property offset values will typically appear as zero. Any changes made are then added to (or subtracted from) the generator's calculated value before the final geometry for that node is created. Curve offsets function similarly for properties that display a Profile Curve in Node Edit Mode; the node's offset curve is added to the generator's curve.9
When a node is selected and the "Art Director" gizmo is active, a specialized node editing gizmo may be presented in the Tree Window. This gizmo provides intuitive, direct manipulation controls for common properties of the selected node. Hovering over the gizmo's controls often reveals tooltips explaining their function. For branches, this might include controls for position, start angle, radius, and length. For leaves, it might allow editing of position, rotation, and various deformation parameters.9
Nodes can be deleted by selecting them and pressing the DEL or BACKSPACE key. A significant behavior is that deleted nodes remain deleted even if the parent generator's properties are subsequently changed (e.g., to produce more nodes). The artist's decision to remove a specific element is thus respected unless explicitly undone.9
All node edits (including deletions) for a particular generator can be cleared by right-clicking the generator's icon in the Generation Editor and selecting an option like "Clear Node Edits." This action will revert all nodes created by that generator to their purely procedural state and will typically restore any deleted nodes. Randomizing parts or all of a tree will also generally remove any relevant node edits.9 This ability to override procedural results with specific artistic decisions, while retaining the underlying procedural framework, is a cornerstone of the SpeedTree workflow.
Section 3.3: Properties: The Language of Control
Properties are the primary mechanism through which users interact with and control the behavior of objects within SpeedTree Modeler. When any object—be it a generator in the Generation Editor, an individual node in the Tree Window, or a scene element like the Light or Fan—is selected, its corresponding list of editable properties is displayed in the Property Bar.35 These properties are where the vast majority of modeling decisions and adjustments are made.
For simpler objects, such as the Light object or the Fan object (which controls wind), properties are typically straightforward, single-value parameters. These might include checkboxes for boolean states (on/off), numerical input fields for values like intensity or speed (often accompanied by sliders if their range is clamped, or thumbwheel-style spinners if unclamped for quick editing), and color pickers.35
However, the properties associated with generators and their resulting nodes are often significantly more complex, reflecting the multifaceted nature of procedural generation. A typical generator property, as described for Modeler 10 35 and reinforced by documentation for earlier versions 34, is often composed of several components:
1. Name: The descriptive label of the property (e.g., "Length," "Radius," "Angle").
2. Graphical Editing Device: A slider or thumbwheel for quick visual adjustment of the base value.
3. Value: The primary numerical input field for the property's base setting.
4. Variance: A parameter that controls the amount of random variation applied to the base value for each node instance.
5. Parent Curve: A clickable icon or area that opens the Curve Editor, allowing the property's effect to be modulated based on the node's position along its parent's structure.
6. Profile Curve: Another clickable icon or area opening the Curve Editor, enabling the property's effect to be shaped along the length of the individual node itself.
This multi-component structure for generator properties provides a rich, layered system for defining behavior. It's not just a single static value, but rather a base value that can be randomized (variance), influenced by its context within the tree's hierarchy (parent curve), and have its application profiled along its own form (profile curve). This combination allows for the creation of very organic and complex results from a relatively concise set of rules.
As detailed in Section 3.2, when a specific node is selected (in Node editing mode), the properties displayed in the Property Bar represent offsets to the values that were originally determined by the node's parent generator.35 This crucial distinction allows artists to make targeted adjustments to individual elements without losing the underlying procedural definition.
Section 3.4: Curves: Sculpting Procedural Behavior with Precision
Curves are a pervasive and exceptionally powerful control mechanism within SpeedTree Modeler, acting as a sophisticated "volume control" or shaping function for a vast majority of properties.38 When a property is controlled by a curve, its static numerical value (as entered in the Property Bar) is typically considered the maximum potential "volume" or effect. The curve then modulates this effect: the vertical position (Y-axis) on the curve at any given point usually represents a percentage or multiplier of that maximum property value, while the horizontal position (X-axis) on the curve determines where along a relevant domain (e.g., parent length, node length, LOD transition) that particular multiplier is applied. The Curve Editor (see Section 2.4.1) is the dedicated interface for viewing and manipulating these curves.37
SpeedTree Modeler utilizes several distinct types of curves, each tailored for specific control scenarios 38:
* Parent Curves (Green):
   * Purpose: These are fundamental for creating realistic foliage behavior where parts of the tree behave or appear differently based on their location of growth relative to their parent structure.
   * Functionality: They distribute property values to child nodes based on how far along their parent's length (or other parent-relative metric) each child node occurs.
   * Evaluation Mode: The horizontal axis of a parent curve can be evaluated in "Relative Mode" (based on the normalized distance between the child's defined(generation-properties.html#boundaries) on the parent) or "Absolute Mode" (based on the absolute Length of the parent).
   * Parent Level Control: A sophisticated feature allowing a single property's parent curve to be influenced by grandparents or even higher ancestors, not just the direct parent. This is controlled via the "Parent Level" setting in the Curve Editor. SpeedTree 8 introduced "compound curves," enabling a property to be affected by curves from multiple parent levels simultaneously (e.g., branch length influenced by both its position on its direct parent branch AND its height on the main trunk).
   * Example: Making branches near the base of a trunk longer and thicker than those near the top by shaping the parent curves for "Length" and "Radius" properties on the branch generator, with the parent level set to the trunk.
* Profile Curves (Light Blue):
   * Purpose: These curves affect each node produced by a generator in the same way, shaping the property's application along the length of the individual node itself.
   * Functionality: The left side of a profile curve typically corresponds to the base of the node, and the right side to its tip.
   * Example: The "Radius" property of a branch often has a profile curve that tapers from a larger value at the base (left side of curve) to a smaller value or zero at the tip (right side of curve), ensuring branches terminate naturally.
   * Interaction: Profile curves work effectively in conjunction with parent curves: the parent curve governs the overall group of nodes, while the profile curve applies its shaping equally to each member of that group.
* Resolution Curves (Orange, often with resolution markers in Curve Editor):
   * Purpose: Specifically used in VFX workflows to control how properties change as the model's overall "Resolution" (High, Medium, Low, Draft) is adjusted (see Section 6.4.3).
   * Example: Decreasing the number of length segments on branches or reducing leaf density when switching to a lower resolution setting for faster previews or exports. The Curve Editor for resolution curves often shows distinct points corresponding to each resolution level.62
* Distribution Curves (Orange):
   * Purpose: Similar to parent curves in that they govern a group of nodes, but they specifically control the spread or density distribution of a fixed number of nodes along a parent.
   * Example: A distribution curve could be used to make level 1 branches cluster more densely near the base and tip of a trunk, with fewer branches occurring in the middle, rather than an even distribution.
* Pruning Curves:
   * Purpose: Each generator typically has one pruning curve that allows for the wholesale removal of nodes based on their position within the tree structure.
   * Example: A pruning curve could be set to remove all branches or leaves that fall below a certain height on the trunk or within a specific radial distance.
* LOD (Level of Detail) Curves (Dark Blue):
   * Purpose: Found only in LOD-specific property groups, these curves govern the progression and intensity of changes for each LOD-aware property across the defined LOD states (see Section 6.4.4).
   * Functionality: The left side of an LOD curve generally corresponds to the highest LOD state (e.g., LOD 1.0), and the right side to the lowest 3D LOD state (e.g., LOD 0.0 before transitioning to billboards). A linear progression is common, simplifying the tree by a roughly equal amount at each LOD step.
   * Adjustments: Artists can modify these curves to make certain LOD effects (like segment reduction or leaf culling) occur earlier or later in the LOD sequence, or to soften transitions that appear too aggressive. Adjusting the endpoints of LOD curves can offer advanced control, such as slightly reducing detail even at the highest LOD state for performance gains, though this should be done with care.38
The sophisticated curve system, particularly the nuanced control offered by Parent Curves with their level and compound evaluation capabilities, allows artists to define incredibly detailed and hierarchical relationships between different parts of a tree. This ability to sculpt procedural behavior with such precision is fundamental to achieving the organic complexity and naturalism characteristic of SpeedTree models.
Table 3.2: SpeedTree Curve Types and Their Applications (Modeler 10)


Curve Type
	Color in UI (Typical)
	Primary Function
	Evaluation Basis (X-axis represents)
	Common Use Cases
	Parent Curve
	Green
	Distributes property values to child nodes based on their position on the parent.
	Normalized position along parent structure (between child's defined boundaries or full parent length).
	Varying branch length/radius with height on trunk; changing leaf size based on position along branch. 38
	Profile Curve
	Light Blue
	Shapes the application of a property along the length of each individual node.
	Normalized position along the node itself (base to tip).
	Tapering branch radius from base to tip; varying leaf color along its length. 38
	Resolution Curve
	Orange
	Modifies properties based on the selected global VFX Resolution state (High, Med, Low, Draft).
	Discrete points corresponding to Resolution states.
	Reducing segment counts or node density at lower resolutions for VFX workflows. 38
	Distribution Curve
	Orange
	Controls the density distribution of a fixed number of nodes along a parent.
	Normalized position along parent structure.
	Clustering branches at specific sections of the trunk; creating uneven leaf distributions. 38
	Pruning Curve
	(Varies)
	Removes entire nodes based on their position within the tree structure.
	Positional criteria (e.g., height, distance from core).
	Removing lower branches for clearance; creating hollow crowns. 38
	LOD Curve
	Dark Blue
	Governs the progression and intensity of property changes across real-time LOD states.
	LOD state (e.g., from 1.0 for highest 3D LOD to 0.0 for lowest 3D LOD).
	Controlling segment reduction, leaf culling rates, or mesh swapping across different Levels of Detail for game assets. 38
	________________
Part IV: Mastering Modeling Techniques
Beyond the foundational concepts of generators, nodes, and properties, SpeedTree Modeler offers a rich suite of advanced procedural and freehand modeling techniques. These tools empower artists to create highly detailed and art-directable vegetation, simulate natural growth phenomena, integrate scanned data, and optimize models for various pipelines.
Section 4.1: Advanced Procedural Techniques
SpeedTree's procedural engine is augmented by a variety of specialized tools and properties that allow for sophisticated control over model generation. These techniques enable artists to introduce complex behaviors, interactions, and optimizations into their creations.8
* Randomization: A cornerstone of procedural generation, randomization in SpeedTree is primarily controlled through "Variance" settings on properties 5 and "Random Seeds" associated with generators or specific property groups.8 Variance defines a range around a base property value, from which random values are picked for each node instance. Seeds provide the starting point for the random number generation; changing a seed produces a different random variation while keeping the underlying rules intact. This allows for the creation of numerous unique tree instances from a single procedural definition.
* Leaf Collision: To prevent unnatural interpenetration of leaves and to optimize rendering by removing hidden or redundant foliage, SpeedTree provides a leaf collision system.8 This system can detect and resolve collisions between leaves (leaf-to-leaf) and between leaves and branches (leaf-to-branch). Options typically include different quality settings (e.g., Low, Medium, High) which balance accuracy with computation speed. Higher quality settings perform more precise intersection tests but are slower, while lower quality settings offer faster computation but might be less exact.18 This feature is crucial for both visual realism and performance, especially in dense canopies.66
* Mesh Anchors: Mesh Anchors are specific points defined on a mesh asset (often via the Cutout Editor, see Section 2.6) that dictate the precise location and orientation for child elements to attach.8 This feature is particularly powerful for low-poly modeling, where a simple base mesh (e.g., a branch cluster card) can be adorned with procedurally placed child elements (like smaller twigs or leaves) at these anchor points, creating a visually complex and full appearance with minimal underlying geometry.43
* Clusters: In SpeedTree terminology, "clusters" often refer to texture maps that depict multiple leaves along with their surrounding small branch structures.43 These are typically used on cards or simple meshes to represent complex foliage formations efficiently. Generators can be configured to place these cluster meshes, and Mesh Anchors on the cluster meshes can then define where further child elements might sprout, adding another layer of detail.8
* Splits: This feature allows branches to bifurcate or divide into multiple distinct ends.8 Procedural controls determine where and how these splits occur, contributing to more organic and natural branching patterns. This is often more realistic than simply having child branches sprout from the side of an unbroken parent branch.
* Shape Control: Shape control enables artists to guide the growth of branches or other tree components towards or within a defined volumetric shape.8 This can be used to create topiaries, force growth around obstacles, or achieve specific artistic silhouettes. The influence of shape control is often visualized as an overlay in the Generation Editor.27
* Procedural Vertex Colors: SpeedTree allows for the generation of vertex colors based on procedural rules and properties.8 These vertex colors can then be used by shaders in the target engine for various effects, such as custom wind animations, localized color variations, or masking specific material effects.
* Geometry Forces: Forces are objects within the SpeedTree scene that can attract, repel, deform, or otherwise influence the generation of tree geometry.8 Users can add various types of forces (e.g., magnet, directional, mesh-based) and apply them to specific generators. Properties control the force's strength, attenuation (how its effect diminishes with distance), and whether it acts as a container (affecting only geometry within its volume). Forces can also influence the alignment of generated elements.56 This system allows for the simulation of environmental influences on growth.
* UV Tiling and Patching: These are techniques for managing texture coordinates (UVs) on procedurally generated geometry, particularly branches.8 UV tiling allows textures to repeat seamlessly along the length or circumference of a branch. UV patching might refer to methods for applying specific texture details or decals to certain areas. Efficient UV management is crucial for texture quality and memory usage.
* Manipulate Mesh Sections: This feature, often used in conjunction with Frond generators and the Cutout Editor (see Section 2.6), allows for the definition and independent manipulation of distinct sections within a frond mesh.8 This enables more complex and nuanced deformations for frond-like structures.
The suite of these advanced procedural techniques provides artists with a deep toolkit for simulating natural growth processes, managing complex interactions between tree components, and optimizing assets for various downstream applications. Features like Mesh Anchors and sophisticated UV controls are particularly indicative of a system designed with real-time performance considerations in mind.
Section 4.2: The Art of Freehand Modeling
While SpeedTree's procedural engine provides a powerful foundation, its "Freehand" modeling toolkit empowers artists with direct, intuitive control to sculpt, refine, and art-direct their creations beyond purely parameter-driven generation.8 This is especially crucial for crafting unique "hero" assets, achieving specific artistic styles, or adding natural imperfections. The Freehand mode, often accessible via the Tree Window toolbar, encompasses several distinct tools 5:
* Bend: Allows artists to intuitively bend and curve branches or other spine-based geometry. Properties associated with the Bend tool control the extent and profile of the bend.8
* Displacement: Enables sculpting or carving features directly onto surfaces, typically branches. This can be used to create knots, burls, cavities, or other surface irregularities. Displacement properties control the strength and nature of the deformation.8
* Trim: Provides tools for cutting or shortening branches, allowing for precise pruning and shaping of the tree's silhouette.8
* Hand Draw: This powerful feature allows artists to draw the path of branches or other spine-based elements directly in the 3D view, often by placing a series of control points that define a Bézier spline.6 The spine of existing hand-drawn branches can be edited by manipulating these control points. A significant workflow enhancement is the ability to convert procedurally generated branches into hand-drawn ones, allowing artists to leverage the speed of proceduralism for initial forms and then switch to detailed manual sculpting for specific areas. Hand-drawn generators can be managed and further configured in the Generation Editor.8
* Click Place: A tool for quickly adding individual instances of generators (like branches, leaves, or decoration meshes) at specific points on the model with a simple click. Properties associated with Click Place control what is placed and how it orients.8
* Vertex Edit: Offers fine-grained control by allowing direct manipulation of individual mesh vertices. Artists can select vertices or groups of vertices and move, rotate, or scale them to locally edit the geometry of a branch or other mesh component. A notable application of Vertex Edit is the ability to add or refine wind rigging data on "hero" meshes, giving precise control over how specific parts of a custom mesh will react to wind animation.8
* Vertex Features: Allows artists to "paint" special feature tags or data onto vertices in Freehand Mode. These features can then be interpreted by other systems or shaders for specialized effects. Properties control the type and intensity of the painted features.8
* Vertex Colors: Enables the direct painting of vertex colors (including alpha) onto the model's geometry in Freehand Mode. This is particularly useful for game artists who need precise control over vertex color data for custom shader effects, localized tinting, or specialized wind weighting.8
The extensive Freehand toolkit demonstrates SpeedTree's commitment to balancing procedural efficiency with artistic freedom. The ability to seamlessly switch between procedural generation and direct manual manipulation, and even convert between them, provides a flexible and powerful workflow for creating highly detailed and customized vegetation.
Section 4.3: Specialized Modeling Workflows
SpeedTree Modeler incorporates specialized workflows and toolsets to address specific, often complex, vegetation modeling challenges, such as creating realistic vines and integrating photogrammetry data.
Sub-Section 4.3.1: Vines
Creating natural-looking vines that realistically interact with other geometry can be a demanding task. SpeedTree Modeler provides dedicated tools for vine generation.8 Historically, this involved:
* Procedural Vine Creation: Generating vines using dedicated Vine generators, with properties controlling their growth patterns, thickness, branching, and leaf placement.
* Manual Placement and Editing: Placing and editing vines by hand for precise artistic control over their paths and interactions.
* Low-Poly Vines for Games: Specific techniques for creating optimized, low-polygon vine assets suitable for real-time applications.
* Vines Following a Guide: A powerful method where vines can be made to grow along a user-defined path or guide spline, combining procedural generation with explicit directional control.
A significant advancement in SpeedTree Modeler 10 is the introduction of physics-based vines.2 This suggests a system where vine growth and behavior can be simulated using physics principles, potentially leading to more natural draping, hanging, and interaction with underlying surfaces compared to purely geometric or path-based methods. This development represents a considerable step towards greater realism and ease of use for creating these complex elements.
Sub-Section 4.3.2: Photogrammetry Integration
The use of photogrammetry—creating 3D models and textures from photographs—has become a staple in modern asset creation for achieving high levels of realism. SpeedTree Modeler includes a robust workflow for integrating scanned data.8 This goes beyond simple mesh importation and involves tools for intelligently converting and combining scanned assets with SpeedTree's procedural systems. Key aspects of the photogrammetry workflow include:
* Photogrammetry in SpeedTree: An overarching approach to utilizing scanned assets.
* Creating Textures from Scans: Tools or best practices for processing textures derived from photogrammetry scans for use in SpeedTree materials. This often involves ensuring textures are properly delit and prepared for PBR workflows.
* Mesh Converter: A pivotal tool, introduced around SpeedTree 9 2, designed to convert imported photogrammetry scan meshes (e.g., of trunks or large branches) into procedural SpeedTree geometry.10 This allows the scanned asset to become a dynamic part of the SpeedTree model, capable of supporting further procedural growth (like new branches or leaves) and reacting to SpeedTree systems like wind and LOD.
* Highlighting Features of Branch Geometry:
   * Feature Vertices: Additional vertices that can be added to procedural or converted mesh geometry to enhance polygonal detail in specific areas where more definition is needed (e.g., around knots or sharp bends).8 These can be painted or procedurally added.
* Texel Density Solutions: Strategies and tools for managing and achieving consistent texel density across models that combine scanned and procedural elements.
* Extending Scanned Trunks: Techniques for seamlessly blending the top of a scanned trunk with procedurally generated upper branches or canopy:
   * Bake Stitch: A method to create a transition mesh that "stitches" procedural geometry onto a scanned base.
   * Texture Blending: Using texture map blending to visually merge the scanned trunk material with the material of procedural extensions.
   * Vertex Blending: Employing vertex alpha or colors to create a smooth geometric and material transition.
* Preparing and Using Branch/Twig Meshes: Workflows for processing scanned branch or twig elements (often captured as clusters) for use as mesh assets within SpeedTree, typically for foliage cards or detail elements.
* Placing Nodes on Photogrammetry Meshes: Techniques for accurately placing procedural child nodes (e.g., new branches, leaves, vines) onto the surface of imported and converted photogrammetry meshes.8
This dedicated photogrammetry toolset signifies SpeedTree's adaptation to contemporary asset creation pipelines, enabling artists to leverage the realism of scanned data while retaining the flexibility and power of procedural modeling.
Sub-Section 4.3.3: Mesh Helpers
Mesh Helpers provide a workflow for adding procedural SpeedTree elements to existing "hero" meshes, which might be custom-modeled trunks, imported sculptures, or any arbitrary static mesh that needs to be adorned with vegetation.8 The concept involves:
* Adding Spines to a Hero Mesh: Defining paths or spines on the surface of the hero mesh along which SpeedTree elements can grow.
* Adding Procedural Branches (or other elements) to a Hero Mesh: Attaching SpeedTree generators (like Branch or Vine generators) to these spines, allowing procedural vegetation to sprout from and interact with the hero mesh.
* Mesh Helper Properties: Specific parameters that control how the Mesh Helper interacts with the target mesh and influences the growth of attached SpeedTree elements.
* Custom Spines Sample: Example files or tutorials demonstrating advanced techniques for creating custom spine setups on hero meshes.8
Mesh Helpers bridge the gap between bespoke, manually created assets and SpeedTree's procedural vegetation system, allowing for flexible integration and art direction.
Section 4.4: Utilizing Forces, Projectors, and Collision Objects
SpeedTree Modeler provides several types of scene objects that, while not always directly part of the tree's visible geometry, play crucial roles in shaping its growth, affecting its appearance, or preparing it for downstream applications.
Sub-Section 4.4.1: Forces
Forces are influential objects that can deform, restrict, attract, repel, or otherwise guide the creation and final form of tree components.8 They are a powerful tool for simulating environmental interactions or achieving specific artistic shapes procedurally. Different types of forces may exist (e.g., Magnet, Directional, Planar, Spherical). A particularly versatile type is the Mesh Force, which uses an arbitrary mesh asset to influence the tree. For example, roots can be made to wrap around a rock mesh, vines can be attracted to a trellis mesh, or branches can be pruned or repelled by an invisible barrier mesh.43
Generators can be configured to be affected by specific forces in the scene, often with properties to control the strength of the influence and how it's applied (e.g., via a profile curve along the affected branches).56 Forces can also affect the initial alignment or orientation of generated elements, not just their final position or shape.56 The use of forces allows artists to introduce sophisticated, naturalistic deformations and interactions into their models without resorting to complex manual sculpting for every detail.
Sub-Section 4.4.2: Projectors
Projectors are scene objects used to project textures or masks onto the surfaces of the tree model.8 This can be used for a variety of effects, such as applying global variations in bark color, projecting grime or moss patterns, or creating complex masking effects that influence material properties or even subsequent procedural generation steps if the projected data can be queried. The Modeler provides tools to set up and configure these projectors, including their shape, orientation, and the texture or mask they apply.
Sub-Section 4.4.3: Collision Objects
Collision Objects in SpeedTree Modeler are simplified geometric primitives (typically spheres and capsules) that can be generated and associated with the tree model.8 Unlike leaf collision (which affects model generation and appearance within the Modeler), these Collision Objects generally do not have a visual impact within the Modeler itself. Instead, their primary purpose is for export to game engines or other real-time applications via the SpeedTree SDK.68
In the target application, these Collision Objects can be queried by the SDK to perform efficient, approximate collision detection with game world elements like player characters, projectiles, or vehicles. This is often used as a fast, initial check before resorting to more computationally expensive per-polygon collision tests.68
Properties for Collision Objects include 68:
* Type: Sphere or Capsule.
* Radius: The radius of the sphere or the ends of the capsule.
* Height: For capsules, defines the length of the cylindrical body.
* User Data: A string field for attaching custom data (e.g., sound effect names, particle types to emit on impact).
* Transform: Position (X/Y/Z) and Rotation (Axis X/Y/Z, Angle) to place the collision object accurately.
SpeedTree Modeler also provides a "Generate Collision Objects" window 69 to automatically create these objects based on the tree's structure. Options include:
* Clear existing objects: Removes any current collision objects.
* Branch capsules: Generates capsule shapes around branch nodes. Parameters control the number of capsules to generate (starting from largest branches) and the percentage of each branch the capsule attempts to encompass.
* Spheres: Generates spherical collision objects based on leaves, mesh forces, or zones. Parameters control the number of spheres and the percentage of the leaf cloud or object extents they try to cover.
While these auto-generated objects provide a good starting point, some manual editing of their position, size, and properties might be necessary for optimal results.69 Collision Objects are a clear example of SpeedTree's design catering to the practical needs of game development, providing tools for performance-conscious runtime interactions.
Section 4.5: Implementing Seasonal Variations and Art Director
SpeedTree Modeler includes features for creating seasonal variations of a tree and high-level artistic shaping tools, allowing for greater versatility and control over the final appearance.
Sub-Section 4.5.1: Seasons
The ability to represent different seasons is crucial for creating dynamic and believable environments. SpeedTree Modeler provides a dedicated "Seasons" system to manage these changes.8 This system allows artists to define how a tree's appearance transforms across a seasonal cycle, typically affecting:
* Leaf Appearance: Changes in leaf color (e.g., green for summer, reds/yellows for autumn), material properties, and potentially the presence or absence of leaves (defoliation for winter).
* Foliage Density: The overall amount of foliage may change with the seasons.
* Other Elements: Presence of flowers in spring/summer, fruits in summer/autumn, or snow accumulation in winter (though snow is often a separate effect or material layer).
The seasonal state is often controlled by a global slider or a numerical value (e.g., 0.0 for spring, progressing through summer and autumn, to 1.0 for winter). The transition between these states is typically managed by curves associated with various properties (e.g., leaf material color, leaf presence probability).70 The introduction of an improved season system was noted as a benefit of upgrading to SpeedTree 8 4, indicating ongoing development in this area. The Seasons feature allows for the efficient creation of multiple visual states from a single underlying tree model, saving significant time compared to modeling each seasonal variant from scratch.
Sub-Section 4.5.2: Art Director
The "Art Director" is a tool or gizmo within SpeedTree Modeler designed for high-level artistic manipulation and shaping of the tree.8 Its icon can be toggled for visibility in the Tree Window via the toolbar.18 When active, especially in conjunction with Node editing mode, the Art Director gizmo provides intuitive controls for influencing the overall silhouette, posture, and key features of the tree.9 This tool likely allows for broader, more gestural edits than tweaking individual numerical properties, bridging the gap between detailed parameter adjustments and overarching artistic intent. It helps artists to quickly establish the main forms and character of a tree before diving into finer details or after procedural generation has created a base.
________________
Part V: Materials, Textures, and Physically Based Rendering (PBR)
The visual fidelity of SpeedTree models is heavily reliant on their materials and textures, and how these interact with light. Since version 8, SpeedTree Modeler has embraced Physically Based Rendering (PBR) as its core rendering and material paradigm, aligning with modern standards in both game development and visual effects.48
Section 5.1: Principles of PBR in SpeedTree
Physically Based Rendering is a methodology that aims to simulate the behavior of light in the real world with greater accuracy than older, more empirical lighting models. By using material parameters that correspond to measurable physical properties of surfaces, PBR allows assets to appear consistently and realistically under a wide variety of lighting conditions.48
The adoption of PBR in SpeedTree Modeler (starting with version 8) marked a significant evolution, leading to changes in how material properties are defined and how lighting is set up within the application.48 This shift ensures that SpeedTree assets can be more seamlessly integrated into contemporary rendering pipelines that are predominantly PBR-based. The benefits include more predictable material responses, easier authoring of realistic surfaces, and improved visual consistency when assets are moved between different PBR-compliant environments. For users seeking a deeper understanding of PBR theory, the SpeedTree documentation often provides links to valuable external resources from industry experts and other rendering technology providers.48
Section 5.2: Comprehensive Guide to Material Maps and Properties
In a PBR system, materials are defined by a set of texture maps and scalar values that describe their physical characteristics. While the specific Modeler 10 page for "Materials and maps" was inaccessible 71, documentation for SpeedTree 9 45 provides an excellent and detailed breakdown of the PBR maps used, which are managed via the Map Editor within the Materials Bar.10 These maps are fundamental to achieving realistic surface appearances:
* Color Map (Albedo/Diffuse):
   * Purpose: Defines the intrinsic base color of the material—what it looks like under pure white light, devoid of specular reflections. For non-metallic surfaces, this is the diffuse color. For metallic surfaces, this map defines the color of the specular reflection.
   * Range: PBR principles dictate that albedo values should fall within a realistic range (nothing is perfectly black or perfectly white in the real world). SpeedTree often includes a diagnostic render mode like "Albedo Check" to help artists validate their color map values (e.g., red indicating values are too high/bright, blue too low/dark).45
* Normal Map:
   * Purpose: Provides fine-scale surface detail by perturbing the per-pixel surface normal, affecting how light reflects off the surface. This creates the illusion of bumps, grooves, and other details without requiring additional geometry.
   * Format: SpeedTree expects tangent-space normal maps. Higher contrast normal maps produce sharper, more pronounced lighting details.45
* Glossiness Map (or Roughness Map):
   * Purpose: Controls the microsurface smoothness or roughness of the material. This directly impacts the appearance of specular reflections.
   * Effect: Low glossiness (high roughness) values result in diffuse, blurry, and dull specular highlights, as light is scattered more widely. High glossiness (low roughness) values produce smaller, sharper, and brighter specular highlights.45 (Note: Some engines use Roughness, which is the inverse of Glossiness).
* Specular Map:
   * Purpose: For non-metallic (dielectric) surfaces, this map scales the intensity of specular reflections. In the real world, the specular reflectivity of dielectrics varies only slightly.
   * Typical Value: Often, a default uniform gray value (e.g., 0.75 gray) is appropriate for most non-metallic surfaces. For very rough surfaces, a "crevice map" might be used here to darken cracks where less light would be reflected.
   * Metals: This map is generally ignored for fully metallic surfaces.45
* Metallic Map:
   * Purpose: Defines how "metal-like" a surface is.
   * Values: Typically binary: 0 for non-metals (dielectrics), 1 for metals. Values between 0 and 1 are rare and usually represent transitional states like corroded or dusty metal.
   * Effect: When set to 1 (metal), the diffuse light contribution effectively becomes black, and the specular reflection is colored by the Color/Albedo map. The Specular map (intensity) is ignored for pure metals. For most tree materials (bark, leaves), metallic should be 0.45
* Subsurface Maps (Subsurface Color and Subsurface Amount/Percentage):
   * Purpose: Simulate the effect of light passing through thin, translucent materials and exiting on the other side. This is crucial for realistic leaves, petals, and thin fronds.
   * Separation: SpeedTree often uses two separate maps for this:
      * Subsurface Color: Defines the color of the light that is transmitted through the material. It's often acceptable for this to be brighter and more saturated than the main Color/Albedo map.
      * Subsurface Amount (or Subsurface %): Controls the intensity or amount of subsurface scattering.
   * Benefit: Having separate color and amount maps provides finer artistic control over the translucency effect compared to a single map or scalar.45
* Ambient Occlusion (AO) Map:
   * Purpose: This texture map provides pre-computed micro-ambient occlusion, simulating self-shadowing that occurs within small corners, crevices, and details of a surface. It helps to ground objects and add depth.
   * Effect: In rendering, the AO map value typically darkens the contribution of ambient light and can also slightly modulate diffuse lighting.
   * Interaction: SpeedTree can also compute per-vertex AO (see Section 6.1). The material's AO map value is often multiplied with the per-vertex AO value, so the AO map itself should generally be mostly white to avoid over-darkening.45
* Custom Map:
   * Purpose: A user-definable texture map slot that is not used by SpeedTree's default render modes within the Modeler.
   * Utility: This map enables extensibility. It can be used by artists or studios to pass specific data through SpeedTree's material system into their own custom shaders or rendering pipelines in external applications. The Custom map data is exported with the tree in mesh formats and is available during texture packing for game formats.45 This is a forward-thinking inclusion for advanced users and pipeline integration.
Mastering the creation and application of these PBR maps is essential for achieving high-quality, realistic rendering of SpeedTree assets in modern pipelines.
Table 5.1: PBR Material Map Reference (SpeedTree Modeler)


Map Name (SpeedTree Terminology)
	Purpose in PBR
	Typical Input Values/Ranges
	SpeedTree Specific Notes & Considerations
	Interaction with Other Maps
	Color Map (Albedo)
	Defines the intrinsic base color of the surface (diffuse for non-metals, specular for metals).
	Values should be within a physically plausible range (e.g., not pure black or white). Luminance often checked.
	"Albedo Check" render mode helps validate values. 45
	Used as diffuse color for dielectrics; used as specular color for metals.
	Normal Map
	Adds fine surface detail by perturbing per-pixel normals.
	Tangent-space RGB texture. Higher contrast = sharper details.
	Expected format is tangent-space. 45
	Affects how all lighting (diffuse, specular) interacts with the surface.
	Glossiness Map
	Controls microsurface smoothness, affecting specular highlight appearance.
	Grayscale. Higher values = smoother, sharper highlights. Lower values = rougher, blurrier highlights.
	Inverse of Roughness.
	Directly determines the size and intensity profile of specular reflections.
	Specular Map
	Scales specular reflection intensity for non-metallic (dielectric) surfaces.
	Grayscale. For most dielectrics, a near-constant mid-gray value (e.g., 0.75) is often used.
	Ignored for fully metallic surfaces. Can use "crevice maps" for very rough surfaces. 45
	Modulates the intensity of reflections calculated based on Glossiness and lighting.
	Metallic Map
	Defines the "metalness" of the surface.
	Grayscale. 0 for non-metals (dielectrics), 1 for metals. Intermediate values are rare.
	For most tree parts (bark, leaves), this should be 0. 45
	If 1 (metal): Diffuse becomes black, Color map tints specular, Specular map is ignored.
	Subsurface Color Map
	Defines the color of light transmitted through thin, translucent materials.
	RGB color. Often brighter and more saturated than the main Color map.
	Part of a two-map system for subsurface scattering. 45
	Works with Subsurface Amount map.
	Subsurface Amount Map
	Controls the intensity/amount of subsurface light scattering.
	Grayscale. Higher values = more light transmission.
	Part of a two-map system for subsurface scattering. 45
	Works with Subsurface Color map.
	Ambient Occlusion (AO) Map
	Provides pre-computed micro-occlusion for self-shadowing effects.
	Grayscale. White = fully lit, Black = fully occluded.
	Multiplied with per-vertex AO computed by SpeedTree; map should be mostly white to avoid over-darkening. 45
	Modulates ambient and sometimes diffuse lighting.
	Custom Map
	User-defined map for custom shader effects or passing data to external pipelines.
	User-defined (e.g., grayscale, RGB).
	Not used by default Modeler render modes. Exported with mesh formats and available in texture packing for game formats. 45
	Dependent on custom shader implementation.
	Section 5.3: Texture Atlases: Creation, Management, and Optimization
Texture atlasing is a critical technique, especially for real-time applications like games, used to improve rendering performance by reducing the number of draw calls. An atlas combines multiple smaller textures (e.g., for different leaves, bark details, or flower parts) into a single larger texture sheet. SpeedTree Modeler provides robust tools and options for creating and managing texture atlases, both for imported textures and during the export process.8
Importance of Atlasing:
Rendering an object typically requires the graphics hardware to switch rendering states and bind new textures for each material applied to it. Each such switch is a "draw call." By consolidating multiple materials' textures into a single atlas, many parts of a tree can be rendered with fewer draw calls, significantly improving performance.50 For game exports, SpeedTree almost always creates an atlas.72
Creating Atlases from Source Textures:
When working with source textures that are already atlases (e.g., a sheet containing textures for several different leaf types), SpeedTree's Mesh Cutout Editor (see Section 2.6) is invaluable. It allows artists to create individual meshes that precisely "cut out" specific elements from the larger atlas texture. Each cutout mesh will have UV coordinates corresponding to its location on the atlas. The "Unwrap" property for materials using such cutouts can be set to "Separate" to ensure each distinct mesh element becomes its own UV island when output atlases are generated during export, improving packing efficiency.72
Generating Atlases During Export:
SpeedTree Modeler provides extensive options for generating texture atlases when exporting models, particularly for game formats 72:
* Atlas Content Control:
   * None: No atlas is created; each material's textures are exported separately.
   * Non-Wrapping: Only materials whose geometry has UVs entirely within the 0-1 range are placed in the atlas. Geometry with wrapping UVs (like tiling bark on branches) will have its textures exported separately.
   * Everything: Attempts to place every material from the entire tree into the atlas. Geometry with UVs outside the 0-1 range will be unwrapped before atlassing. This can sometimes lead to suboptimal layouts if not carefully managed, but features like V-wrapping can mitigate this.
* Allow Separate Atlases: If materials have been configured in the Material Asset Bar to belong to different atlases (e.g., one for opaque parts, one for transparent parts), this option respects that setup during export.
* Allow V-Wrapping (V-Tiling): This is a crucial optimization for branch textures. Branch textures often tile vertically (V-axis) many times along a branch. If such a texture were fully unwrapped to fit into an atlas, it would become very long and thin, leading to inefficient use of atlas space and loss of texture resolution for other elements. V-wrapping places these textures in the atlas such that their top and bottom edges touch the atlas boundaries, allowing them to tile vertically while still being part of the atlas. U-axis wrapping (horizontal) still needs consideration, but V-wrapping is highly beneficial for typical branch texturing.72
* Separate Materials: Even when materials are combined into an atlas, this option allows them to be split based on rendering properties not stored in textures (e.g., the two-sided flag). This is useful if different parts of the tree (like opaque branches vs. alpha-blended leaves) require different shader configurations or render queue sorting in the game engine.73
* Ignore Smooth LOD: For some export formats that might split geometry for different vertex shaders (e.g., .ST for Unreal Engine), the smooth LOD transitions unique to SpeedTree can sometimes increase draw calls. If SpeedTree-style vertex morphing LOD is not being used, this option can be enabled to prioritize fewer draw calls by ignoring smooth LOD requirements when merging geometry types.73
* Atlas Editing: During game export, users can often click a button to "Show Atlas" and manually edit the automatically generated layout. Tools for translating, rotating, and scaling individual texture islands within the atlas are provided. However, manual editing carries the risk of creating overlapping textures, which will not render correctly.73
* Combining Multiple Trees: SpeedTree 8 and later versions introduced the ability to export multiple tree models simultaneously and have them share a single texture atlas.14 This is a significant optimization for scenes with varied foliage, further reducing the total number of unique textures and draw calls.
* UV Seams for Branches: SpeedTree 9 introduced a feature where actual geometry cuts ("UV Seams") can be created at UV tile boundaries on branch generators. This results in UVs that are entirely within the 0-1 range for each segment, allowing these smaller texture pieces to be packed more intelligently into atlases than continuously wrapping textures.72
* Material Atlas Handling: The "Atlas:Handling" property on the Material Asset Bar can be used to "Force out" a specific material, ensuring it is never cut apart or repacked into an atlas and is instead copied as is.72
UDIM Export (VFX):
While SpeedTree Modeler does not typically import meshes with UDIM UV setups, it can export tree meshes that use UDIMs for VFX pipelines. When unwrapping UVs during a static mesh export, selecting "UDIM" instead of "Atlas" will save each UV island that would have gone into an atlas into its own separate texture file, numbered according to the UDIM standard (e.g., 1001, 1002, etc.).72 This caters to VFX workflows where UDIMs are common for managing high-resolution textures.
The comprehensive atlas generation and management tools in SpeedTree Modeler reflect a deep understanding of texture optimization requirements for both real-time and VFX pipelines, providing artists with considerable control over the final texture output.
________________
Part VI: Illumination, Animation, and In-Modeler Rendering
SpeedTree Modeler provides an integrated environment for lighting, animating, and rendering vegetation models. This allows artists to preview and refine their creations under various conditions before exporting them to external applications. The system encompasses directional and ambient lighting, ambient occlusion, wind animation, growth simulation, and various rendering modes, including support for Level of Detail (LOD) and VFX-focused Resolution previews.
Section 6.1: Lighting Systems: Directional, Ambient, AO, and Lightmapping
The Modeler incorporates a lighting system that enables artists to simulate different environmental lighting conditions, providing crucial visual feedback for material authoring and model shaping.8
* Directional Lighting:
   * Concept: Represents a single, global, parallel light source, typically assumed to be the sun.76
   * Control: A Light object, often visualized as a gizmo in the top-right corner of the Tree Window, controls the directional light's rotation (and thus direction), color, and intensity. This gizmo can be directly manipulated, or its properties can be edited in the Property Bar.75 A common shortcut is holding 'V' and dragging the mouse in the Tree Window to rotate the light relative to the current view.76
   * Shadows: The directional light casts shadows from the tree onto itself and potentially onto a ground plane. Shadow quality can often be adjusted, involving a trade-off with rendering performance within the Modeler.75
   * Presets: Lighting presets (e.g., "Standard," "Golden Hour," "Night," "Overcast") are often available to quickly set the directional light's color, intensity, and other environmental parameters.18
* Ambient Lighting:
   * Concept: Represents the indirect light in the scene that does not come directly from the main light source but rather from the environment (e.g., skylight, bounced light). Ambient light illuminates shadowed areas, preventing them from being completely black.75
   * Control:
      * 3-Color System: Ambient light can be defined using three colors: Sky color (at the apex), Horizon color, and Ground color. These are interpolated to form the background gradient in the Tree Window and contribute to the ambient illumination on the model.74
      * HDRI (High Dynamic Range Image): The Modeler can import and use spherically mapped HDRIs (e.g., in .hdr or .exr format) for image-based ambient lighting. This provides much richer and more realistic environmental illumination and reflections. The HDRI can also serve as the background in the Tree Window. Properties allow control over the HDRI's intensity and its tinting effect on directional, specular, and subsurface components of the tree's lighting.74
   * Intensity: The overall intensity of the ambient light can be adjusted.75
* Ambient Occlusion (AO) - In-Modeler Calculation:
   * Concept: Ambient occlusion simulates the shadowing that occurs in crevices, intersections, and dense areas of the tree where ambient light is blocked or "occluded." This adds depth and realism to the model's shading.75 This is distinct from material-based AO maps (Section 5.2).
   * Calculation: AO can be computed within the Modeler (e.g., via a toolbar button, menu option "Tools > Render ambient occlusion," or hotkey 'O'). The calculation is relatively quick but not continuous; it needs to be re-rendered if the tree's geometry changes. AO is typically computed when a model is first loaded.77
   * Refinement: Properties are available to refine the computed AO, such as Brightness, Contrast, Min (darkest AO value), and Max (lightest AO value). A "Ground AO" effect can also be applied, darkening the base of the tree and spreading up to a certain distance, with controllable blur.74
   * Visualization: A dedicated "AO" render mode allows artists to visualize the computed AO values directly on the tree for easier editing and tuning.75
* Lighting Leaves and Fronds: While the specific Modeler 10 page was not detailed, this topic 8 likely covers particular techniques or material properties relevant to achieving realistic lighting on foliage, considering effects like translucency (subsurface scattering) and the complex interplay of light within canopies.
* Lightmap UVs:
   * Purpose: SpeedTree can generate a unique, non-overlapping set of UV coordinates (a second UV channel) specifically for lightmapping.8 Lightmaps are textures used in game engines and other renderers to store pre-calculated (baked) lighting information, significantly improving rendering performance for static lighting scenarios.
   * Export: The option to include these lightmap UVs is typically available during model export, especially for game formats.73 The "Lightmap:Weight" property on Zone generators 59 can influence how much space that zone's geometry receives in the lightmap texture.
* Light Object Reference: The main Light object in the scene has its own set of properties, detailed in SpeedTree 9 documentation 74, covering the Environment settings (directional and ambient), Ground AO, Normals adjustments, Tonemapping, and AO post-processing.
* Normal Manipulation for Lighting: SpeedTree provides tools to adjust vertex normals to fine-tune shading and lighting effects, particularly for foliage 74:
   * Puffs: Adjusts vertex normals relative to the model's anatomical structure, helping to create a sense of volume.
   * Scale-based Adjustments (Tiny, Small, Medium, Large, Huge): Modifies normals at different scales to affect local or global lighting appearance.
   * Up-Vector Biasing: Angles vertex normals up or down along the Z-axis, useful for uniformly lighting elements like grass.
   * Projector-based Normal Adjustment: Can adjust vertex normals relative to a mesh asset used as a geometry force, if normals projection is enabled on the force.
   * Flip Backside Normals: By default, normals on the backside of two-sided geometry are flipped to ensure correct specular response.
This comprehensive lighting system within the Modeler, including HDRI support and AO computation, provides artists with a sophisticated preview environment. This allows for more informed material and modeling decisions before exporting, reducing iteration cycles with external rendering applications. The subtle normal adjustment tools further enhance the ability to achieve nuanced and realistic lighting on complex vegetation.
Section 6.2: Wind Animation: Systems, Tuning, and Best Practices
SpeedTree Modeler features a powerful and scalable wind animation system, enabling artists to bring their vegetation models to life with realistic motion, from gentle breezes to stormy conditions. The system is designed to cater to diverse pipeline needs, offering different algorithms and a multitude of parameters for fine-tuning.78
Core Wind Components and Workflow:
* Fan Object: The primary control point for global wind settings. Its properties change based on the selected wind algorithm. It is often visualized as a gizmo in the Tree Window.78
* Generator Wind Properties: Individual generators (especially Branch, Leaf, and Frond types) have their own wind-specific properties that determine how their generated nodes react to the global wind conditions.81
* Wind Wizard: A tool ("Tools > Wind wizard…" or via the Wind menu on the Tree Window toolbar) designed to automatically set initial wind properties for the entire model based on its structure. This provides a good starting point for further tuning.18
* Wind Levels: Wind effects often propagate through the tree based on "wind levels," determined by the generator hierarchy. The Tree generator is level 0, its direct children with wind enabled are level 1, and so on. This allows for different wind behaviors at different parts of the tree (e.g., trunk sways differently than twigs).81 The Generation Editor often displays the wind level on each enabled generator. Typically, up to four distinct levels of branch wind are tuned.
* Gusting: The system supports wind gusts, which are temporary increases in wind strength and frequency, adding to realism. Gust parameters (strength, frequency, range) can be controlled via the Fan object or overlays.18
* Preview: Wind animation can be previewed directly in the Tree Window when enabled (e.g., via hotkey '8' or the "Enabled" property on the Fan).81
Wind Algorithms (Modeler 10) 78:
* VFX Wind: Designed for creating high-quality, detailed wind animations suitable for film, animation, and other offline rendering applications. This mode typically offers the most comprehensive set of controls and can produce very complex motion, but may be computationally intensive.80
* Games Wind: The preferred real-time wind mode for models intended for use with SpeedTree 9 (and later) SDKs or compatible game engines. It balances visual quality with performance, implementing wind effects largely through vertex shaders.79
* Legacy UE4/Unity Wind: Provided for creating wind animations compatible with older versions of Unreal Engine (UE4) and Unity that do not support the newer Games wind system.
* Lumberyard Wind: Tailored to leverage Amazon Lumberyard's native wind mechanism.
Key Wind Tuning Concepts and Properties (often found on Fan object and generators):
* Global Motion (Branches): Side-to-side swaying of the entire tree or major branches, based on height. An option to "Preserve Shape" can correct skewing during long sways, resulting in more natural motion at a slight performance cost.80
* Branch Motion (Bending & Turbulence):
   * Bending: Controls how much branches bend in response to wind.
   * Turbulence/Rolling: Simulates smaller, more chaotic movements and oscillations along branches. Different levels of rolling (e.g., Level 1, Level 2) offer varying complexity and performance impact.80
* Leaf Motion (Ripple & Tumble):
   * Ripple: Simulates leaves fluttering or rippling in the wind. Can be based on vertex normals or a computed oscillation vector (the latter being more versatile but potentially slower).80
   * Tumble: Simulates leaves or groups of leaves tumbling or rotating.
   * Occlusion: A feature that scales back wind effects on the leeward (downwind) side of the model, preventing leaves from appearing to blow through themselves. This is a relatively inexpensive effect.80
* Frond Motion (Ripple): Specific rippling effects for frond geometry, with options for one-sided or two-sided motion (two-sided being more suitable for fronds with distinct top/bottom surfaces but requiring more data).80
* Rolling Wind (Global Effect): A more global, wave-like motion that can affect the entire canopy, particularly noticeable in grass and subtly in trees. This can be a computationally expensive effect.80
* Frequencies and Response Times: Properties controlling how quickly elements oscillate and how fast they react to changes in wind strength. These need to be tuned for realism; for example, small, wispy models should have shorter response times than large, heavy trees.81
* Strength Curves: Wind behavior across different strengths (from calm to stormy) is often controlled by curves, allowing artists to define how motion parameters (e.g., bend amount, ripple frequency) change as overall wind intensity varies.81 Preset conditions like "Breezy" or "Stormy" on the Fan object or wind toolbar menu help set nominal strength and gusting for these conditions.18
Performance Considerations and Best Practices 80:
* Wind effects, especially complex ones, can significantly impact performance, particularly vertex shader instruction counts.
* Start with the Wind Wizard to get a reasonable baseline.
* "Less is typically more"—avoid excessively large, sweeping motions. Medium bending and small turbulences often look more natural.
* Tune frequencies appropriately; even in calm conditions, some high-frequency micro-movements can add realism.
* Ensure response times are consistent for models intended for the same scene.
* For LOD in games, transition to simpler wind (e.g., "Global" rocking) or no wind as quickly as visually acceptable. For full wind, transitioning from "Full" to "Global" in the next LOD level can work well.
* Disable expensive features (like detailed rolling or two-sided frond ripple) if not essential for the desired look or target platform.
Exporting Wind Animation:
For VFX pipelines, wind animation is often exported as a point cache (e.g., Alembic .abc or FBX cache) by enabling "Wind" (and "Wind gusting" if desired) in the export dialog.81 For game engines, the wind setup in the Modeler is baked into the exported file (e.g., .stsdk, .st, .st9), and the animation is recreated at runtime by the engine's SpeedTree integration using vertex shaders and noise textures.79
Localized Wind (SDK Feature):
The SpeedTree SDK also supports localized, omnidirectional wind sources (e.g., simulating a helicopter's downwash). This is achieved by techniques such as using each tree instance's world position as an offset into shader noise lookups (preventing synchronized animation) and applying unique wind vectors to each instance based on its position relative to the local wind source. An optional decay effect can weaken the wind's influence with distance from the source.82
SpeedTree's wind system is a deep and flexible feature set. Its scalability allows it to be tailored for a wide range of applications, from subtle ambient motion in real-time environments to dramatic, high-fidelity animations for cinematic productions.
Section 6.3: Growth Animation and Timeline Control
In addition to wind animation, SpeedTree Modeler provides capabilities for creating growth animations, simulating the development of a tree over time.8 This feature allows artists to generate sequences depicting a tree sprouting from a sapling and maturing into its full form, or to animate specific growth phases.
While detailed mechanics of the growth animation system are not extensively covered in the provided snippets, its presence is noted in the Modeler 10 documentation map.8 The process likely involves animating various generator properties over time—such as length, radius, segment counts, and the activation of different generator levels—to mimic natural development.
The Timeline Bar is a UI component mentioned in older SpeedTree documentation 41 and listed for Modeler 10.8 This bar serves as the primary interface for controlling and previewing time-based effects, including growth animations and potentially complex, choreographed wind sequences. It would typically allow users to:
* Scrub through time to preview the animation at different frames or stages.
* Set keyframes for properties that are being animated.
* Define the overall duration and playback speed of the animation.
The ability to create growth animations extends SpeedTree's utility beyond static model creation, making it suitable for VFX shots requiring dynamic plant growth, educational visualizations, or specialized simulations where the temporal development of vegetation is important.
Section 6.4: Rendering within the Modeler: Modes, Resolution, and LOD
SpeedTree Modeler includes an internal rendering engine that provides immediate visual feedback during the modeling process. This allows artists to assess the appearance of their creations, diagnose issues, and preview how they will look under different lighting conditions or at varying levels of complexity before exporting.
Sub-Section 6.4.1: Physically Based Rendering (PBR)
As detailed in Part V, SpeedTree Modeler's viewport utilizes a Physically Based Rendering (PBR) system.48 This ensures that materials and lighting behave in a physically plausible manner, providing a more accurate preview of how the model will appear in modern PBR-compliant game engines and offline renderers.
Sub-Section 6.4.2: Render Modes
The Modeler offers various render modes, accessible via the "Render" menu in the Tree Window toolbar 18, to help artists visualize different aspects of their model or diagnose specific issues:
* Standard Lit Mode: The default rendering mode, showing the tree with full materials and lighting.
* Unlit Mode: Displays the model with only its base Color/Albedo textures, without any lighting influence.
* Wireframe Mode: Shows the underlying polygonal mesh structure.
* Normals Mode: Visualizes vertex normals (and often tangents and binormals), crucial for diagnosing shading problems. Normals are typically color-coded (e.g., normals in blue, tangents in red, binormals in green).18
* Ambient Occlusion (AO) Mode: Displays the computed per-vertex AO values, allowing artists to assess and tune the AO effect.75
* Albedo Check Mode: A diagnostic mode to help validate that Color/Albedo
Works cited
1. SpeedTree model import - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/6000.1/Documentation/Manual/SpeedTree.html
2. Frequently Asked Questions (F.A.Q.) - SpeedTree, accessed June 6, 2025, https://store.speedtree.com/faq/
3. SpeedTree Modeler 10 User Manual - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/index.html
4. Upgrading Old Models - SpeedTree 8, accessed June 6, 2025, https://docs8.speedtree.com/modeler/doku.php?id=upgrade
5. Modeling Approach - SpeedTree 8, accessed June 6, 2025, https://docs8.speedtree.com/modeler/doku.php?id=kcmodelingapproach
6. Getting Started - SpeedTree Documentation, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=gettingstarted
7. docs.unity3d.com, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/modeling-approach.html
8. Documentation map - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/doc-map.html
9. Nodes - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/nodes.html
10. start [SpeedTree Documentation], accessed June 6, 2025, https://docs9.speedtree.com/modeler/
11. Create, open, or save files - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/create-open-or-save-files.html
12. Units - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/units.html
13. docs.unity3d.com, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/upgrade-old-models.html
14. SpeedTree for Lumberyard Updates and New Models, accessed June 6, 2025, https://store.speedtree.com/speedtree-lumberyard-updates-new-models/
15. docs.unity3d.com, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/ui-overview.html
16. User interface - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/user-interface.html
17. overview [SpeedTree Documentation], accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=overview
18. Tree Window toolbar reference - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/tree-window-toolbar-reference.html
19. Tree Window toolbar reference - SpeedTree 9 Documentation, accessed June 6, 2025, http://docs9.speedtree.com/modeler/doku.php?id=tree-window-toolbar-reference
20. Tree Window - SpeedTree 8, accessed June 6, 2025, https://docs8.speedtree.com/modeler/doku.php?id=tooltree_window
21. complexmodels [SpeedTree Documentation], accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=complexmodels
22. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/customize-the-viewport.html
23. Tree Window - SpeedTree Documentation, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=tree_window
24. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/tree-window-navigation.html
25. Tree Window overlays - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/tree-window-overlays.html
26. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/tree-window-properties.html
27. Generation Editor - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/generation-editor.html
28. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/generation-editor-toolbar-reference.html
29. Generation Editor toolbar reference - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=generation-editor-toolbar-reference
30. docs.unity3d.com, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/property-bar.html
31. Property Bar - SpeedTree 8, accessed June 6, 2025, https://docs8.speedtree.com/modeler/doku.php?id=property_bar
32. Property Editor - SpeedTree Documentation, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=propertyeditoroverview
33. toolpropertybar [SpeedTree Documentation], accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=toolpropertybar
34. Properties - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=properties
35. Introduction to properties - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/intro-to-properties.html
36. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/curve-editor.html
37. Curve Editor - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=toolcurve_editor
38. Curves - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/curves.html
39. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/variance-editor.html
40. docs.unity3d.com, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/assets.html
41. SpeedTree Modeler User Manual, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=modeler
42. Mesh Assets - SpeedTree Documentation, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=mesh_assets
43. Meshes - SpeedTree 8, accessed June 6, 2025, https://docs8.speedtree.com/modeler/doku.php?id=kcmeshes
44. Meshes Bar - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=toolmeshesbar
45. Materials and maps - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=kcmaterialspbr
46. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/common-asset-settings.html
47. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/materials-bar.html
48. Physically based rendering - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/physically-based-rendering.html
49. Glossary - SpeedTree Documentation, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=glossary
50. Glossary - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=glossary
51. Cutout Editor - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/cutout-editor.html
52. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/intro-to-generators.html
53. Manage generators - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/manage-generators.html
54. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/generator-types.html
55. accessed December 31, 1969, https://docs9.speedtree.com/modeler/doku.php?id=generator_types
56. Frond generator - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=frond_generator
57. Frond Generator - SpeedTree 8, accessed June 6, 2025, https://docs8.speedtree.com/modeler/doku.php?id=frond_generator
58. Batched Leaf Generator - SpeedTree 8, accessed June 6, 2025, https://docs8.speedtree.com/modeler/doku.php?id=batchedleaf_generator
59. Zone generator - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=zone_generator
60. Zone Generator - SpeedTree Documentation, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=zone_generator
61. Generation properties - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=generation_properties
62. Resolution curves - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=kcvfxresolution
63. Branch generator - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/branch-generator.html
64. Frond generator - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/frond-generator.html
65. Level of detail - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/level-of-detail.html
66. Real-Time Modeling - SpeedTree Documentation, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=real-time_modeling_tips
67. SpeedTree 9: New Artist-Centric Workflows for Photogrammetry and Freehand Creation | First Look - YouTube, accessed June 6, 2025, https://www.youtube.com/watch?v=LRzeK4EmYW4
68. Collision object - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=collision_object
69. Generate Collision Objects window reference - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=generate-collision-objects-window-reference
70. SpeedTree 8 | 01 | Interface Overview - YouTube, accessed June 6, 2025, https://www.youtube.com/watch?v=OJOSCjq9IQw
71. accessed December 31, 1969, https://docs.unity3d.com/speedtree-modeler/manual/materials-and-maps.html
72. Texture atlases - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=atlases
73. Games export options - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/games-export-options.html
74. Lighting - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/modeler/doku.php?id=light
75. lighting [SpeedTree Documentation], accessed June 6, 2025, http://docs8.speedtree.com/modeler/doku.php?id=lighting
76. Directional lighting - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/directional-lighting.html
77. Ambient lighting - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/ambient-lighting.html
78. Wind - Unity - Manual, accessed June 6, 2025, https://docs.unity3d.com/speedtree-modeler/manual/wind.html
79. Wind overview - SpeedTree 9 Documentation, accessed June 6, 2025, https://docs9.speedtree.com/sdk/doku.php?id=wind-overview
80. Performance - SpeedTree Documentation, accessed June 6, 2025, https://docs.speedtree.com/doku.php?id=performance
81. VFX Wind - SpeedTree 8, accessed June 6, 2025, https://docs8.speedtree.com/modeler/doku.php?id=windvfx
82. Local wind effect - SpeedTree 9 Documentation, accessed June 6, 2025, http://docs9.speedtree.com/sdk/doku.php?id=local-wind-effect