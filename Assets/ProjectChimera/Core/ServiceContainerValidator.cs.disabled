using System;
using System.Collections.Generic;
using System.Linq;

using UnityEngine;
using ProjectChimera.Core.Logging;

namespace ProjectChimera.Core
{
    /// <summary>
    /// Validation and verification component for ServiceContainer separated to follow Single Responsibility Principle.
    /// Handles container validation, dependency graph analysis, and health checks.
    /// </summary>
    public class ServiceContainerValidator
    {
        private readonly IServiceContainer _container;
        private readonly List<string> _validationErrors = new List<string>();
        private readonly List<string> _validationWarnings = new List<string>();

        public ServiceContainerValidator(IServiceContainer container)
        {
            _container = container ?? throw new ArgumentNullException(nameof(container));
        }

        /// <summary>
        /// Performs comprehensive container verification including dependency graph validation.
        /// </summary>
        public ContainerVerificationResult Verify()
        {
            _validationErrors.Clear();
            _validationWarnings.Clear();

            try
            {
                // Validate all service registrations
                ValidateServiceRegistrations();

                // Check for circular dependencies
                ValidateDependencyGraph();

                // Validate service lifecycles
                ValidateServiceLifecycles();

                // Check for missing dependencies
                ValidateDependencies();

                // Performance validations
                ValidatePerformanceConsiderations();

                return new ContainerVerificationResult
                {
                    IsValid = _validationErrors.Count == 0,
                    ValidationMessages = _validationErrors.Concat(_validationWarnings).ToList(),
                    Errors = _validationErrors.ToList(),
                    Warnings = _validationWarnings.ToList(),
                    ValidationTimestamp = DateTime.Now
                };
            }
            catch (Exception ex)
            {
                _validationErrors.Add($"Validation failed with exception: {ex.Message}");
                return new ContainerVerificationResult
                {
                    IsValid = false,
                    ValidationMessages = _validationErrors.ToList(),
                    Errors = _validationErrors.ToList(),
                    Warnings = _validationWarnings.ToList(),
                    ValidationTimestamp = DateTime.Now
                };
            }
        }

        /// <summary>
        /// Validates all service registrations can be instantiated.
        /// </summary>
        private void ValidateServiceRegistrations()
        {
            var registrations = _container.GetRegistrationInfo();

            foreach (var registration in registrations)
            {
                try
                {
                    if (registration.Lifetime != ServiceLifetime.Singleton || !registration.HasInstance)
                    {
                        // Try to resolve the service to check if it can be instantiated
                        var service = _container.TryResolve(registration.ServiceType);
                        if (service == null && _container.IsRegistered(registration.ServiceType))
                        {
                            _validationErrors.Add($"Service {registration.ServiceType.Name} is registered but cannot be resolved");
                        }
                    }
                }
                catch (Exception ex)
                {
                    _validationErrors.Add($"Service {registration.ServiceType.Name} registration validation failed: {ex.Message}");
                }
            }
        }

        /// <summary>
        /// Validates the dependency graph for circular dependencies.
        /// </summary>
        private void ValidateDependencyGraph()
        {
            var registrations = _container.GetRegistrationInfo();
            var dependencyGraph = BuildDependencyGraph(registrations);

            var circularDependencies = DetectCircularDependencies(dependencyGraph);
            foreach (var cycle in circularDependencies)
            {
                _validationErrors.Add($"Circular dependency detected: {string.Join(" -> ", cycle)}");
            }
        }

        /// <summary>
        /// Validates service lifecycles for potential issues.
        /// </summary>
        private void ValidateServiceLifecycles()
        {
            var registrations = _container.GetRegistrationInfo();

            // Check for singleton depending on transient (potential memory leaks)
            foreach (var registration in registrations)
            {
                if (registration.Lifetime == ServiceLifetime.Singleton)
                {
                    var dependencies = GetServiceDependencies(registration.ServiceType);
                    foreach (var dependency in dependencies)
                    {
                        var depRegistration = registrations.FirstOrDefault(r => r.ServiceType == dependency);
                        if (depRegistration != null && depRegistration.Lifetime == ServiceLifetime.Transient)
                        {
                            _validationWarnings.Add($"Singleton service {registration.ServiceType.Name} depends on transient service {dependency.Name} - potential memory leak");
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Validates that all dependencies are registered.
        /// </summary>
        private void ValidateDependencies()
        {
            var registrations = _container.GetRegistrationInfo();

            foreach (var registration in registrations)
            {
                var dependencies = GetServiceDependencies(registration.ServiceType);
                foreach (var dependency in dependencies)
                {
                    if (!_container.IsRegistered(dependency))
                    {
                        _validationErrors.Add($"Service {registration.ServiceType.Name} depends on unregistered service {dependency.Name}");
                    }
                }
            }
        }

        /// <summary>
        /// Validates performance-related considerations.
        /// </summary>
        private void ValidatePerformanceConsiderations()
        {
            var registrations = _container.GetRegistrationInfo().ToList();

            // Check for excessive singleton registrations
            var singletonCount = registrations.Count(r => r.Lifetime == ServiceLifetime.Singleton);
            if (singletonCount > 50) // Arbitrary threshold
            {
                _validationWarnings.Add($"High number of singleton services ({singletonCount}) may impact startup performance");
            }

            // Check for excessive transient registrations that could be singletons
            var transientCount = registrations.Count(r => r.Lifetime == ServiceLifetime.Transient);
            if (transientCount > 100) // Arbitrary threshold
            {
                _validationWarnings.Add($"High number of transient services ({transientCount}) may impact runtime performance");
            }

            // Check for services with deep dependency chains
            foreach (var registration in registrations)
            {
                var dependencyDepth = CalculateDependencyDepth(registration.ServiceType);
                if (dependencyDepth > 5) // Arbitrary threshold
                {
                    _validationWarnings.Add($"Service {registration.ServiceType.Name} has deep dependency chain (depth: {dependencyDepth})");
                }
            }
        }

        /// <summary>
        /// Builds a dependency graph for the registered services.
        /// </summary>
        private Dictionary<Type, List<Type>> BuildDependencyGraph(IEnumerable<ServiceRegistrationInfo> registrations)
        {
            var graph = new Dictionary<Type, List<Type>>();

            foreach (var registration in registrations)
            {
                var dependencies = GetServiceDependencies(registration.ServiceType);
                graph[registration.ServiceType] = dependencies.ToList();
            }

            return graph;
        }

        /// <summary>
        /// Detects circular dependencies in the dependency graph.
        /// </summary>
        private List<List<Type>> DetectCircularDependencies(Dictionary<Type, List<Type>> graph)
        {
            var circularDependencies = new List<List<Type>>();
            var visited = new HashSet<Type>();
            var recursionStack = new HashSet<Type>();
            var currentPath = new List<Type>();

            foreach (var serviceType in graph.Keys)
            {
                if (!visited.Contains(serviceType))
                {
                    DetectCircularDependenciesRecursive(serviceType, graph, visited, recursionStack, currentPath, circularDependencies);
                }
            }

            return circularDependencies;
        }

        /// <summary>
        /// Recursive helper for circular dependency detection.
        /// </summary>
        private bool DetectCircularDependenciesRecursive(Type serviceType, Dictionary<Type, List<Type>> graph,
            HashSet<Type> visited, HashSet<Type> recursionStack, List<Type> currentPath, List<List<Type>> circularDependencies)
        {
            visited.Add(serviceType);
            recursionStack.Add(serviceType);
            currentPath.Add(serviceType);

            if (graph.TryGetValue(serviceType, out var dependencies))
            {
                foreach (var dependency in dependencies)
                {
                    if (!visited.Contains(dependency))
                    {
                        if (DetectCircularDependenciesRecursive(dependency, graph, visited, recursionStack, currentPath, circularDependencies))
                        {
                            return true;
                        }
                    }
                    else if (recursionStack.Contains(dependency))
                    {
                        // Found circular dependency
                        var cycleStartIndex = currentPath.IndexOf(dependency);
                        var cycle = currentPath.Skip(cycleStartIndex).ToList();
                        cycle.Add(dependency); // Complete the cycle
                        circularDependencies.Add(cycle);
                        return true;
                    }
                }
            }

            recursionStack.Remove(serviceType);
            currentPath.RemoveAt(currentPath.Count - 1);
            return false;
        }

        /// <summary>
        /// Gets the dependencies for a service type by analyzing constructors.
        /// </summary>
        private IEnumerable<Type> GetServiceDependencies(Type serviceType)
        {
            var dependencies = new List<Type>();

            if (serviceType.IsInterface || serviceType.IsAbstract)
            {
                // For interfaces, we can't determine dependencies directly
                return dependencies;
            }

            var constructors = serviceType.GetConstructors();
            var primaryConstructor = constructors.OrderByDescending(c => c.GetParameters().Length).FirstOrDefault();

            if (primaryConstructor != null)
            {
                var parameters = primaryConstructor.GetParameters();
                dependencies.AddRange(parameters.Select(p => p.ParameterType));
            }

            return dependencies;
        }

        /// <summary>
        /// Calculates the dependency depth for a service type.
        /// </summary>
        private int CalculateDependencyDepth(Type serviceType, HashSet<Type> visited = null)
        {
            if (visited == null)
                visited = new HashSet<Type>();

            if (visited.Contains(serviceType))
                return 0; // Avoid infinite recursion

            visited.Add(serviceType);

            var dependencies = GetServiceDependencies(serviceType);
            if (!dependencies.Any())
                return 0;

            var maxDepth = dependencies.Max(dep => CalculateDependencyDepth(dep, new HashSet<Type>(visited)));
            return maxDepth + 1;
        }

        /// <summary>
        /// Performs a health check on all registered services.
        /// </summary>
        public ServiceHealthReport PerformHealthCheck()
        {
            var report = new ServiceHealthReport
            {
                CheckTimestamp = DateTime.Now,
                ServiceHealth = new Dictionary<Type, ServiceHealthStatus>()
            };

            var registrations = _container.GetRegistrationInfo();

            foreach (var registration in registrations)
            {
                try
                {
                    var service = _container.TryResolve(registration.ServiceType);
                    var status = service != null ? ServiceStatus.Healthy : ServiceStatus.Failed;
                    report.ServiceHealth[registration.ServiceType] = new ServiceHealthStatus
                    {
                        Status = status,
                        StatusMessage = service != null ? "OK" : "Resolution failed",
                        LastCheck = DateTime.Now
                    };
                }
                catch (Exception ex)
                {
                    report.ServiceHealth[registration.ServiceType] = new ServiceHealthStatus
                    {
                        Status = ServiceStatus.Failed,
                        StatusMessage = ex.Message,
                        LastCheck = DateTime.Now
                    };
                    report.HealthIssues.Add($"Service {registration.ServiceType.Name}: {ex.Message}");
                }
            }

            report.TotalServices = registrations.Count();
            report.HealthyServices = report.ServiceHealth.Values.Count(h => h.Status == ServiceStatus.Healthy);
            report.UnhealthyServices = report.ServiceHealth.Values.Count(h => h.Status == ServiceStatus.Warning);
            report.CriticalServices = report.ServiceHealth.Values.Count(h => h.Status == ServiceStatus.Failed);

            return report;
        }
    }

    // ContainerVerificationResult moved to DITypes.cs to avoid duplication

    // ServiceHealthReport moved to ServiceHealthMonitor.cs to avoid duplication

    // ServiceHealthStatus moved to ServiceHealthMonitor.cs to avoid duplication
}
