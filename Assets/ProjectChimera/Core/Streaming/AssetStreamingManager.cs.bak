using UnityEngine;
using System.Collections.Generic;
using System.Collections;
using ProjectChimera.Core.Memory;
using System;

using ProjectChimera.Core.Logging;
namespace ProjectChimera.Core.Streaming
{
    /// <summary>
    /// STREAMING: Advanced asset streaming system for optimal memory usage
    /// Manages loading/unloading of assets based on distance and priority
    /// Week 11: Asset Streaming & LOD System
    /// </summary>
    public class AssetStreamingManager : MonoBehaviour
    {
        [Header("Streaming Settings")]
        [SerializeField] private bool _enableStreaming = true;
        [SerializeField] private bool _enableLogging = true;
        [SerializeField] private float _streamingRadius = 100f;
        [SerializeField] private float _unloadRadius = 150f;
        [SerializeField] private int _maxConcurrentLoads = 3;
        [SerializeField] private float _streamingUpdateInterval = 0.5f;

        [Header("Priority Settings")]
        [SerializeField] private StreamingPriority _defaultPriority = StreamingPriority.Medium;
        [SerializeField] private float _highPriorityRadius = 50f;
        [SerializeField] private float _lowPriorityRadius = 200f;

        [Header("Memory Management")]
        [SerializeField] private long _memoryThreshold = 512 * 1024 * 1024; // 512MB
        [SerializeField] private int _maxCachedAssets = 100;
        [SerializeField] private float _unusedAssetLifetime = 30f;

        public enum StreamingPriority
        {
            VeryLow,
            Low,
            Medium,
            High,
            Critical
        }

        // Asset tracking
        private readonly Dictionary<string, StreamedAsset> _streamedAssets = new Dictionary<string, StreamedAsset>();
        private readonly Dictionary<string, object> _loadingOperations = new Dictionary<string, object>();
        private readonly Queue<StreamingRequest> _loadQueue = new Queue<StreamingRequest>();
        private readonly Queue<string> _unloadQueue = new Queue<string>();

        // Reference tracking
        private Transform _streamingCenter; // Usually main camera
        private float _lastStreamingUpdate;
        private int _currentConcurrentLoads = 0;

        // Statistics
        private StreamingStats _stats = new StreamingStats();

        private static AssetStreamingManager _instance;
        public static AssetStreamingManager Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = FindObjectOfType<AssetStreamingManager>();
                    if (_instance == null)
                    {
                        var go = new GameObject("AssetStreamingManager");
                        _instance = go.AddComponent<AssetStreamingManager>();
                        DontDestroyOnLoad(go);
                    }
                }
                return _instance;
            }
        }

        private void Awake()
        {
            if (_instance == null)
            {
                _instance = this;
                DontDestroyOnLoad(gameObject);
                Initialize();
            }
            else if (_instance != this)
            {
                Destroy(gameObject);
            }
        }

        /// <summary>
        /// Initialize streaming manager
        /// </summary>
        public void Initialize()
        {
            // Default streaming center to main camera
            if (_streamingCenter == null)
            {
                var mainCamera = Camera.main;
                if (mainCamera != null)
                {
                    _streamingCenter = mainCamera.transform;
                }
                else
                {
                    _streamingCenter = transform;
                }
            }

            _lastStreamingUpdate = Time.time;

            if (_enableLogging)
            {
                ChimeraLogger.LogInfo("AssetStreamingManager", "$1");
            }
        }

        private void Update()
        {
            if (!_enableStreaming) return;

            if (Time.time - _lastStreamingUpdate >= _streamingUpdateInterval)
            {
                UpdateStreaming();
                _lastStreamingUpdate = Time.time;
            }

            ProcessLoadQueue();
            ProcessUnloadQueue();
            UpdateAssetLifetimes();
        }

        /// <summary>
        /// Set the streaming center (usually main camera)
        /// </summary>
        public void SetStreamingCenter(Transform center)
        {
            _streamingCenter = center;
        }

        /// <summary>
        /// Register asset for streaming
        /// </summary>
        public void RegisterAsset(string assetKey, Vector3 position, StreamingPriority priority = StreamingPriority.Medium, string[] tags = null)
        {
            if (string.IsNullOrEmpty(assetKey)) return;

            if (_streamedAssets.ContainsKey(assetKey))
            {
                // Update existing asset
                var existing = _streamedAssets[assetKey];
                existing.Position = position;
                existing.Priority = priority;
                existing.LastAccessTime = Time.time;
                return;
            }

            var streamedAsset = new StreamedAsset
            {
                AssetKey = assetKey,
                Position = position,
                Priority = priority,
                Tags = tags ?? new string[0],
                RegistrationTime = Time.time,
                LastAccessTime = Time.time,
                LoadState = AssetLoadState.Unloaded
            };

            _streamedAssets[assetKey] = streamedAsset;
            _stats.RegisteredAssets++;

            if (_enableLogging)
            {
                ChimeraLogger.LogInfo("AssetStreamingManager", $1);
            }
        }

        /// <summary>
        /// Unregister asset from streaming
        /// </summary>
        public void UnregisterAsset(string assetKey)
        {
            if (string.IsNullOrEmpty(assetKey) || !_streamedAssets.ContainsKey(assetKey))
                return;

            var asset = _streamedAssets[assetKey];

            // Cancel loading if in progress
            if (asset.LoadState == AssetLoadState.Loading && _loadingOperations.ContainsKey(assetKey))
            {
                Addressables.Release(_loadingOperations[assetKey]);
                _loadingOperations.Remove(assetKey);
                _currentConcurrentLoads--;
            }

            // Unload if loaded
            if (asset.LoadState == AssetLoadState.Loaded && asset.AssetHandle.IsValid())
            {
                Addressables.Release(asset.AssetHandle);
            }

            _streamedAssets.Remove(assetKey);
            _stats.RegisteredAssets--;

            if (_enableLogging)
            {
                ChimeraLogger.LogInfo("AssetStreamingManager", $1);
            }
        }

        /// <summary>
        /// Request immediate load of asset
        /// </summary>
        public T LoadAssetImmediate<T>(string assetKey) where T : UnityEngine.Object
        {
            if (_streamedAssets.ContainsKey(assetKey))
            {
                _streamedAssets[assetKey].Priority = StreamingPriority.Critical;
                _streamedAssets[assetKey].LastAccessTime = Time.time;
            }

            return Addressables.LoadAssetAsync<T>(assetKey);
        }

        /// <summary>
        /// Get loaded asset if available
        /// </summary>
        public T GetLoadedAsset<T>(string assetKey) where T : UnityEngine.Object
        {
            if (_streamedAssets.TryGetValue(assetKey, out var asset))
            {
                if (asset.LoadState == AssetLoadState.Loaded && asset.AssetHandle.IsValid())
                {
                    asset.LastAccessTime = Time.time;
                    return asset.AssetHandle.Result as T;
                }
            }
            return null;
        }

        /// <summary>
        /// Check if asset is loaded
        /// </summary>
        public bool IsAssetLoaded(string assetKey)
        {
            if (_streamedAssets.TryGetValue(assetKey, out var asset))
            {
                return asset.LoadState == AssetLoadState.Loaded && asset.AssetHandle.IsValid();
            }
            return false;
        }

        /// <summary>
        /// Force unload asset
        /// </summary>
        public void UnloadAsset(string assetKey)
        {
            if (_streamedAssets.TryGetValue(assetKey, out var asset))
            {
                if (asset.LoadState == AssetLoadState.Loaded && asset.AssetHandle.IsValid())
                {
                    Addressables.Release(asset.AssetHandle);
                    asset.LoadState = AssetLoadState.Unloaded;
                    asset.AssetHandle = default;
                    _stats.UnloadedAssets++;
                }
            }
        }

        /// <summary>
        /// Get streaming statistics
        /// </summary>
        public StreamingStats GetStats()
        {
            _stats.LoadedAssets = 0;
            _stats.LoadingAssets = 0;
            _stats.CurrentMemoryUsage = GC.GetTotalMemory(false);

            foreach (var asset in _streamedAssets.Values)
            {
                switch (asset.LoadState)
                {
                    case AssetLoadState.Loaded:
                        _stats.LoadedAssets++;
                        break;
                    case AssetLoadState.Loading:
                        _stats.LoadingAssets++;
                        break;
                }
            }

            return _stats;
        }

        /// <summary>
        /// Clear all streaming data
        /// </summary>
        public void ClearAll()
        {
            // Cancel all loading operations
            foreach (var handle in _loadingOperations.Values)
            {
                if (handle.IsValid())
                {
                    Addressables.Release(handle);
                }
            }

            // Unload all loaded assets
            foreach (var asset in _streamedAssets.Values)
            {
                if (asset.LoadState == AssetLoadState.Loaded && asset.AssetHandle.IsValid())
                {
                    Addressables.Release(asset.AssetHandle);
                }
            }

            _streamedAssets.Clear();
            _loadingOperations.Clear();
            _loadQueue.Clear();
            _unloadQueue.Clear();
            _currentConcurrentLoads = 0;

            if (_enableLogging)
            {
                ChimeraLogger.LogInfo("AssetStreamingManager", "$1");
            }
        }

        #region Private Methods

        /// <summary>
        /// Update streaming based on distance and priority
        /// </summary>
        private void UpdateStreaming()
        {
            if (_streamingCenter == null) return;

            Vector3 center = _streamingCenter.position;

            foreach (var kvp in _streamedAssets)
            {
                var assetKey = kvp.Key;
                var asset = kvp.Value;

                float distance = Vector3.Distance(center, asset.Position);
                StreamingPriority effectivePriority = CalculateEffectivePriority(asset, distance);

                // Determine if we should load or unload
                bool shouldBeLoaded = ShouldAssetBeLoaded(distance, effectivePriority);
                bool isLoaded = asset.LoadState == AssetLoadState.Loaded;
                bool isLoading = asset.LoadState == AssetLoadState.Loading;

                if (shouldBeLoaded && !isLoaded && !isLoading)
                {
                    QueueAssetLoad(assetKey, effectivePriority);
                }
                else if (!shouldBeLoaded && isLoaded)
                {
                    QueueAssetUnload(assetKey);
                }

                // Update distance for statistics
                asset.DistanceFromCenter = distance;
            }
        }

        /// <summary>
        /// Calculate effective priority based on distance and base priority
        /// </summary>
        private StreamingPriority CalculateEffectivePriority(StreamedAsset asset, float distance)
        {
            StreamingPriority basePriority = asset.Priority;

            // Boost priority if close
            if (distance <= _highPriorityRadius)
            {
                return (StreamingPriority)Mathf.Min((int)basePriority + 1, (int)StreamingPriority.Critical);
            }
            // Reduce priority if far
            else if (distance >= _lowPriorityRadius)
            {
                return (StreamingPriority)Mathf.Max((int)basePriority - 1, (int)StreamingPriority.VeryLow);
            }

            return basePriority;
        }

        /// <summary>
        /// Determine if asset should be loaded based on distance and priority
        /// </summary>
        private bool ShouldAssetBeLoaded(float distance, StreamingPriority priority)
        {
            if (distance > _unloadRadius) return false;

            // Priority-based loading distance
            float loadDistance = _streamingRadius;
            switch (priority)
            {
                case StreamingPriority.Critical:
                    loadDistance = _streamingRadius * 1.5f;
                    break;
                case StreamingPriority.High:
                    loadDistance = _streamingRadius * 1.2f;
                    break;
                case StreamingPriority.VeryLow:
                    loadDistance = _streamingRadius * 0.5f;
                    break;
                case StreamingPriority.Low:
                    loadDistance = _streamingRadius * 0.8f;
                    break;
            }

            return distance <= loadDistance;
        }

        /// <summary>
        /// Queue asset for loading
        /// </summary>
        private void QueueAssetLoad(string assetKey, StreamingPriority priority)
        {
            var request = new StreamingRequest
            {
                AssetKey = assetKey,
                Priority = priority,
                RequestTime = Time.time
            };

            _loadQueue.Enqueue(request);
        }

        /// <summary>
        /// Queue asset for unloading
        /// </summary>
        private void QueueAssetUnload(string assetKey)
        {
            _unloadQueue.Enqueue(assetKey);
        }

        /// <summary>
        /// Process load queue with concurrent load limiting
        /// </summary>
        private void ProcessLoadQueue()
        {
            while (_loadQueue.Count > 0 && _currentConcurrentLoads < _maxConcurrentLoads)
            {
                var request = _loadQueue.Dequeue();
                StartAssetLoad(request.AssetKey);
            }
        }

        /// <summary>
        /// Start loading an asset
        /// </summary>
        private void StartAssetLoad(string assetKey)
        {
            if (!_streamedAssets.ContainsKey(assetKey)) return;

            var asset = _streamedAssets[assetKey];
            if (asset.LoadState != AssetLoadState.Unloaded) return;

            // Check memory pressure
            if (GC.GetTotalMemory(false) > _memoryThreshold)
            {
                if (_enableLogging)
                {
                    ChimeraLogger.LogWarning("AssetStreamingManager", $1);
                }
                return;
            }

            asset.LoadState = AssetLoadState.Loading;
            _currentConcurrentLoads++;

            var handle = Addressables.LoadAssetAsync<UnityEngine.Object>(assetKey);
            _loadingOperations[assetKey] = handle;

            handle.Completed += (op) => OnAssetLoadCompleted(assetKey, op);

            _stats.LoadRequests++;
        }

        /// <summary>
        /// Handle asset load completion
        /// </summary>
        private void OnAssetLoadCompleted(string assetKey, object handle)
        {
            _currentConcurrentLoads--;
            _loadingOperations.Remove(assetKey);

            if (_streamedAssets.TryGetValue(assetKey, out var asset))
            {
                if (handle.Status == AsyncOperationStatus.Succeeded)
                {
                    asset.LoadState = AssetLoadState.Loaded;
                    asset.AssetHandle = handle;
                    asset.LastAccessTime = Time.time;
                    _stats.LoadedAssets++;

                    if (_enableLogging)
                    {
                        ChimeraLogger.LogInfo("AssetStreamingManager", $1);
                    }
                }
                else
                {
                    asset.LoadState = AssetLoadState.Failed;
                    _stats.FailedLoads++;

                    if (_enableLogging)
                    {
                        ChimeraLogger.LogError("AssetStreamingManager", $1);
                    }
                }
            }
        }

        /// <summary>
        /// Process unload queue
        /// </summary>
        private void ProcessUnloadQueue()
        {
            while (_unloadQueue.Count > 0)
            {
                string assetKey = _unloadQueue.Dequeue();
                UnloadAsset(assetKey);
            }
        }

        /// <summary>
        /// Update asset lifetimes and unload unused assets
        /// </summary>
        private void UpdateAssetLifetimes()
        {
            float currentTime = Time.time;
            var keysToUnload = new List<string>();

            foreach (var kvp in _streamedAssets)
            {
                var asset = kvp.Value;

                if (asset.LoadState == AssetLoadState.Loaded &&
                    currentTime - asset.LastAccessTime > _unusedAssetLifetime &&
                    asset.DistanceFromCenter > _streamingRadius)
                {
                    keysToUnload.Add(kvp.Key);
                }
            }

            foreach (var key in keysToUnload)
            {
                QueueAssetUnload(key);
            }
        }

        #endregion

        private void OnDestroy()
        {
            ClearAll();
        }
    }

    #region Data Structures

    /// <summary>
    /// Represents a streamed asset
    /// </summary>
    [System.Serializable]
    public class StreamedAsset
    {
        public string AssetKey;
        public Vector3 Position;
        public AssetStreamingManager.StreamingPriority Priority;
        public string[] Tags;
        public AssetLoadState LoadState;
        public object AssetHandle;
        public float RegistrationTime;
        public float LastAccessTime;
        public float DistanceFromCenter;
    }

    /// <summary>
    /// Asset load states
    /// </summary>
    public enum AssetLoadState
    {
        Unloaded,
        Loading,
        Loaded,
        Failed
    }

    /// <summary>
    /// Streaming request
    /// </summary>
    [System.Serializable]
    public struct StreamingRequest
    {
        public string AssetKey;
        public AssetStreamingManager.StreamingPriority Priority;
        public float RequestTime;
    }

    /// <summary>
    /// Streaming statistics
    /// </summary>
    [System.Serializable]
    public struct StreamingStats
    {
        public int RegisteredAssets;
        public int LoadedAssets;
        public int LoadingAssets;
        public int UnloadedAssets;
        public int LoadRequests;
        public int FailedLoads;
        public long CurrentMemoryUsage;
    }

    #endregion
}
