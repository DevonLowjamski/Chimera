using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Collections;
using ProjectChimera.Core.Memory;
using ProjectChimera.Core.Input;
using ProjectChimera.Systems.UI.Pooling;

namespace ProjectChimera.Systems.UI
{
    /// <summary>
    /// PERFORMANCE: Optimized UI management system for cultivation interfaces
    /// Reduces UI update overhead and provides efficient rendering for large plant counts
    /// Week 12: Input & UI Performance
    /// </summary>
    public class OptimizedUIManager : MonoBehaviour
    {
        [Header("UI Optimization Settings")]
        [SerializeField] private bool _enableUIOptimization = true;
        [SerializeField] private bool _enableLogging = false;
        [SerializeField] private float _uiUpdateInterval = 0.1f; // 10 FPS for UI updates
        [SerializeField] private int _maxUIUpdatesPerFrame = 20;

        [Header("Canvas Optimization")]
        [SerializeField] private bool _enableCanvasCulling = true;
        [SerializeField] private bool _enableBatchedUpdates = true;
        [SerializeField] private float _canvasCullDistance = 200f;

        [Header("Element Pooling")]
        [SerializeField] private bool _enableUIPooling = true;
        [SerializeField] private int _initialPoolSize = 50;
        [SerializeField] private int _maxPoolSize = 200;

        // UI System components
        private UIElementPool _uiElementPool;
        private readonly Dictionary<string, OptimizedUIPanel> _activePanels = new Dictionary<string, OptimizedUIPanel>();
        private readonly MemoryOptimizedQueue<UIUpdateRequest> _updateQueue = new MemoryOptimizedQueue<UIUpdateRequest>();

        // Batched updates
        private readonly Dictionary<UIUpdateType, List<IUIUpdatable>> _batchedUpdates = new Dictionary<UIUpdateType, List<IUIUpdatable>>();
        private readonly List<Canvas> _managedCanvases = new List<Canvas>();

        // Performance tracking
        private float _lastUIUpdateTime;
        private int _uiUpdatesThisFrame;
        private UIPerformanceStats _stats = new UIPerformanceStats();
        private UIPerformanceMonitor _performanceMonitor;

        // UI Elements for cultivation system
        private readonly Dictionary<string, PlantInfoPanel> _plantInfoPanels = new Dictionary<string, PlantInfoPanel>();
        private readonly List<ProgressBar> _activeProgressBars = new List<ProgressBar>();
        private readonly Queue<NotificationUI> _notificationQueue = new Queue<NotificationUI>();

        public static OptimizedUIManager Instance { get; private set; }

        public bool IsInitialized { get; private set; }
        public UIPerformanceStats Stats => _stats;

        // Events
        public System.Action<string> OnPanelOpened;
        public System.Action<string> OnPanelClosed;
        public System.Action<UIPerformanceStats> OnPerformanceUpdate;

        private void Awake()
        {
            if (Instance == null)
            {
                Instance = this;
                DontDestroyOnLoad(gameObject);
                Initialize();
            }
            else if (Instance != this)
            {
                Destroy(gameObject);
            }
        }

        /// <summary>
        /// Initialize optimized UI manager
        /// </summary>
        public void Initialize()
        {
            if (IsInitialized) return;

            InitializeUIElementPool();
            InitializeBatchedUpdateSystem();
            SetupCanvasOptimization();
            RegisterWithInputSystem();
            InitializePerformanceMonitoring();

            _lastUIUpdateTime = Time.unscaledTime;
            IsInitialized = true;

            if (_enableLogging)
            {
                Debug.Log("[OptimizedUIManager] UI optimization initialized");
            }
        }

        private void Update()
        {
            if (!_enableUIOptimization || !IsInitialized) return;

            _uiUpdatesThisFrame = 0;
            
            UpdateUISystem();
            ProcessUpdateQueue();
            UpdateCanvasCulling();
            ProcessNotifications();

            _stats.UpdateCycles++;
        }

        /// <summary>
        /// Create optimized plant info panel
        /// </summary>
        public PlantInfoPanel CreatePlantInfoPanel(string plantId, Vector3 worldPosition)
        {
            if (_plantInfoPanels.ContainsKey(plantId))
            {
                return _plantInfoPanels[plantId];
            }

            RectTransform panelRT = null;
            
            if (_enableUIPooling && _uiElementPool != null)
            {
                panelRT = _uiElementPool.GetUIElement(UIElementPool.UIElementType.PlantInfoPanel);
            }

            if (panelRT == null)
            {
                // Fallback to direct instantiation
                var panelGO = new GameObject($"PlantInfoPanel_{plantId}");
                panelRT = panelGO.AddComponent<RectTransform>();
            }

            var plantPanel = panelRT.GetComponent<PlantInfoPanel>();
            if (plantPanel == null)
            {
                plantPanel = panelRT.gameObject.AddComponent<PlantInfoPanel>();
            }

            plantPanel.Initialize(plantId, worldPosition);
            _plantInfoPanels[plantId] = plantPanel;

            // Register for batched updates
            RegisterForBatchedUpdate(UIUpdateType.PlantInfo, plantPanel);

            _stats.PanelsCreated++;

            if (_enableLogging)
            {
                Debug.Log($"[OptimizedUIManager] Created plant info panel for: {plantId}");
            }

            return plantPanel;
        }

        /// <summary>
        /// Remove plant info panel
        /// </summary>
        public void RemovePlantInfoPanel(string plantId)
        {
            if (_plantInfoPanels.TryGetValue(plantId, out var panel))
            {
                UnregisterFromBatchedUpdate(UIUpdateType.PlantInfo, panel);
                
                if (_enableUIPooling && _uiElementPool != null)
                {
                    _uiElementPool.ReturnUIElement(UIElementPool.UIElementType.PlantInfoPanel, panel.GetComponent<RectTransform>());
                }
                else
                {
                    Destroy(panel.gameObject);
                }

                _plantInfoPanels.Remove(plantId);
                _stats.PanelsDestroyed++;

                if (_enableLogging)
                {
                    Debug.Log($"[OptimizedUIManager] Removed plant info panel for: {plantId}");
                }
            }
        }

        /// <summary>
        /// Create progress bar for operations
        /// </summary>
        public ProgressBar CreateProgressBar(string operationId, string title, float duration)
        {
            RectTransform progressRT = null;
            
            if (_enableUIPooling && _uiElementPool != null)
            {
                progressRT = _uiElementPool.GetUIElement(UIElementPool.UIElementType.ProgressBar);
            }

            if (progressRT == null)
            {
                var progressGO = new GameObject($"ProgressBar_{operationId}");
                progressRT = progressGO.AddComponent<RectTransform>();
            }

            var progressBar = progressRT.GetComponent<ProgressBar>();
            if (progressBar == null)
            {
                progressBar = progressRT.gameObject.AddComponent<ProgressBar>();
            }

            progressBar.Initialize(operationId, title, duration);
            _activeProgressBars.Add(progressBar);

            RegisterForBatchedUpdate(UIUpdateType.Progress, progressBar);

            _stats.ProgressBarsCreated++;
            return progressBar;
        }

        /// <summary>
        /// Show notification message
        /// </summary>
        public void ShowNotification(string message, NotificationType type = NotificationType.Info, float duration = 3f)
        {
            var notification = new NotificationUI
            {
                Message = message,
                Type = type,
                Duration = duration,
                StartTime = Time.unscaledTime
            };

            _notificationQueue.Enqueue(notification);
            _stats.NotificationsQueued++;
        }

        /// <summary>
        /// Register UI panel for optimization
        /// </summary>
        public void RegisterUIPanel(string panelId, OptimizedUIPanel panel)
        {
            if (!_activePanels.ContainsKey(panelId))
            {
                _activePanels[panelId] = panel;
                panel.Initialize();
                
                OnPanelOpened?.Invoke(panelId);
                _stats.RegisteredPanels++;

                if (_enableLogging)
                {
                    Debug.Log($"[OptimizedUIManager] Registered UI panel: {panelId}");
                }
            }
        }

        /// <summary>
        /// Unregister UI panel
        /// </summary>
        public void UnregisterUIPanel(string panelId)
        {
            if (_activePanels.TryGetValue(panelId, out var panel))
            {
                panel.Cleanup();
                _activePanels.Remove(panelId);
                
                OnPanelClosed?.Invoke(panelId);
                _stats.RegisteredPanels--;

                if (_enableLogging)
                {
                    Debug.Log($"[OptimizedUIManager] Unregistered UI panel: {panelId}");
                }
            }
        }

        /// <summary>
        /// Queue UI update request
        /// </summary>
        public void QueueUIUpdate(UIUpdateRequest request)
        {
            _updateQueue.Enqueue(request);
            _stats.UpdatesQueued++;
        }

        /// <summary>
        /// Set UI update rate for specific type
        /// </summary>
        public void SetUIUpdateRate(UIUpdateType updateType, float updateRate)
        {
            // Implementation would adjust update frequencies per type
            if (_enableLogging)
            {
                Debug.Log($"[OptimizedUIManager] Set update rate for {updateType}: {updateRate} Hz");
            }
        }

        #region Private Methods

        /// <summary>
        /// Initialize UI element pool
        /// </summary>
        private void InitializeUIElementPool()
        {
            if (!_enableUIPooling) return;

            var poolGO = new GameObject("UIElementPool");
            poolGO.transform.SetParent(transform);
            
            _uiElementPool = poolGO.AddComponent<UIElementPool>();
            _uiElementPool.Initialize();
        }

        /// <summary>
        /// Initialize batched update system
        /// </summary>
        private void InitializeBatchedUpdateSystem()
        {
            if (!_enableBatchedUpdates) return;

            // Initialize batched update lists
            foreach (UIUpdateType updateType in System.Enum.GetValues(typeof(UIUpdateType)))
            {
                _batchedUpdates[updateType] = new List<IUIUpdatable>();
            }
        }

        /// <summary>
        /// Set up canvas optimization
        /// </summary>
        private void SetupCanvasOptimization()
        {
            if (!_enableCanvasCulling) return;

            // Find all canvases and add them to managed list
            var canvases = FindObjectsOfType<Canvas>();
            foreach (var canvas in canvases)
            {
                if (canvas.renderMode == RenderMode.WorldSpace)
                {
                    _managedCanvases.Add(canvas);
                }
            }
        }

        /// <summary>
        /// Register with input system for UI events
        /// </summary>
        private void RegisterWithInputSystem()
        {
            if (OptimizedInputManager.Instance != null)
            {
                OptimizedInputManager.Instance.OnMouseClick += OnUIMouseClick;
                OptimizedInputManager.Instance.OnOptimizedMouseMove += OnUIMouseMove;
            }
        }

        /// <summary>
        /// Update UI system with optimization
        /// </summary>
        private void UpdateUISystem()
        {
            float currentTime = Time.unscaledTime;
            
            if (currentTime - _lastUIUpdateTime >= _uiUpdateInterval)
            {
                UpdateBatchedSystems();
                UpdateActivePanels();
                _lastUIUpdateTime = currentTime;
            }
        }

        /// <summary>
        /// Update batched UI systems
        /// </summary>
        private void UpdateBatchedSystems()
        {
            if (!_enableBatchedUpdates) return;

            foreach (var kvp in _batchedUpdates)
            {
                var updateType = kvp.Key;
                var updatables = kvp.Value;

                // Update in batches to prevent frame drops
                int updatesThisType = 0;
                int maxUpdatesPerType = _maxUIUpdatesPerFrame / _batchedUpdates.Count;

                for (int i = 0; i < updatables.Count && updatesThisType < maxUpdatesPerType; i++)
                {
                    var updatable = updatables[i];
                    if (updatable != null && updatable.ShouldUpdate())
                    {
                        updatable.UpdateUI();
                        updatesThisType++;
                        _uiUpdatesThisFrame++;
                    }
                }
            }
        }

        /// <summary>
        /// Update active UI panels
        /// </summary>
        private void UpdateActivePanels()
        {
            foreach (var panel in _activePanels.Values)
            {
                if (panel != null && panel.IsVisible && panel.ShouldUpdate())
                {
                    panel.UpdatePanel();
                    _uiUpdatesThisFrame++;
                    
                    if (_uiUpdatesThisFrame >= _maxUIUpdatesPerFrame)
                        break;
                }
            }
        }

        /// <summary>
        /// Process UI update queue
        /// </summary>
        private void ProcessUpdateQueue()
        {
            while (_updateQueue.Count > 0 && _uiUpdatesThisFrame < _maxUIUpdatesPerFrame)
            {
                if (_updateQueue.TryDequeue(out var request))
                {
                    ProcessUIUpdateRequest(request);
                    _uiUpdatesThisFrame++;
                }
            }
        }

        /// <summary>
        /// Process individual UI update request
        /// </summary>
        private void ProcessUIUpdateRequest(UIUpdateRequest request)
        {
            switch (request.Type)
            {
                case UIUpdateType.PlantInfo:
                    if (_plantInfoPanels.TryGetValue(request.ElementId, out var panel))
                    {
                        panel.UpdatePlantData(request.Data);
                    }
                    break;
                    
                case UIUpdateType.Progress:
                    // Find and update progress bar
                    var progressBar = _activeProgressBars.Find(p => p.OperationId == request.ElementId);
                    if (progressBar != null)
                    {
                        progressBar.UpdateProgress((float)request.Data);
                    }
                    break;
            }

            _stats.UpdatesProcessed++;
        }

        /// <summary>
        /// Update canvas culling based on distance
        /// </summary>
        private void UpdateCanvasCulling()
        {
            if (!_enableCanvasCulling) return;

            var cameraPos = Camera.main?.transform.position ?? Vector3.zero;

            foreach (var canvas in _managedCanvases)
            {
                if (canvas == null) continue;

                float distance = Vector3.Distance(cameraPos, canvas.transform.position);
                bool shouldBeVisible = distance <= _canvasCullDistance;
                
                if (canvas.enabled != shouldBeVisible)
                {
                    canvas.enabled = shouldBeVisible;
                    _stats.CanvasCullOperations++;
                }
            }
        }

        /// <summary>
        /// Process notification queue
        /// </summary>
        private void ProcessNotifications()
        {
            float currentTime = Time.unscaledTime;
            
            // Process one notification per frame to avoid spikes
            if (_notificationQueue.Count > 0)
            {
                var notification = _notificationQueue.Dequeue();
                DisplayNotification(notification);
                _stats.NotificationsDisplayed++;
            }
        }

        /// <summary>
        /// Display individual notification
        /// </summary>
        private void DisplayNotification(NotificationUI notification)
        {
            RectTransform notificationRT = null;
            
            if (_enableUIPooling && _uiElementPool != null)
            {
                notificationRT = _uiElementPool.GetUIElement(UIElementPool.UIElementType.NotificationBanner);
            }

            if (notificationRT != null)
            {
                var notificationComp = notificationRT.GetComponent<NotificationDisplay>();
                if (notificationComp == null)
                {
                    notificationComp = notificationRT.gameObject.AddComponent<NotificationDisplay>();
                }

                notificationComp.Show(notification);
                StartCoroutine(HideNotificationAfterDelay(notificationComp, notification.Duration));
            }
        }

        /// <summary>
        /// Hide notification after delay
        /// </summary>
        private IEnumerator HideNotificationAfterDelay(NotificationDisplay notification, float delay)
        {
            yield return new WaitForSeconds(delay);
            
            if (notification != null)
            {
                notification.Hide();
                
                if (_enableUIPooling && _uiElementPool != null)
                {
                    _uiElementPool.ReturnUIElement(UIElementPool.UIElementType.NotificationBanner, notification.GetComponent<RectTransform>());
                }
                else
                {
                    Destroy(notification.gameObject);
                }
            }
        }

        /// <summary>
        /// Register for batched updates
        /// </summary>
        private void RegisterForBatchedUpdate(UIUpdateType updateType, IUIUpdatable updatable)
        {
            if (_enableBatchedUpdates && _batchedUpdates.ContainsKey(updateType))
            {
                _batchedUpdates[updateType].Add(updatable);
            }
        }

        /// <summary>
        /// Unregister from batched updates
        /// </summary>
        private void UnregisterFromBatchedUpdate(UIUpdateType updateType, IUIUpdatable updatable)
        {
            if (_enableBatchedUpdates && _batchedUpdates.ContainsKey(updateType))
            {
                _batchedUpdates[updateType].Remove(updatable);
            }
        }

        #region Input Handlers

        private void OnUIMouseClick(Vector2 position)
        {
            // Handle UI mouse clicks with optimization
            _stats.MouseClicks++;
        }

        private void OnUIMouseMove(Vector2 position)
        {
            // Handle optimized mouse movement for UI
            _stats.MouseMoves++;
        }

        #endregion

        #endregion

        /// <summary>
        /// Initialize performance monitoring integration
        /// </summary>
        private void InitializePerformanceMonitoring()
        {
            _performanceMonitor = UIPerformanceMonitor.Instance;
            if (_performanceMonitor != null)
            {
                _performanceMonitor.Initialize();
            }
        }

        /// <summary>
        /// Set update batch size for optimization
        /// </summary>
        public void SetUpdateBatchSize(int batchSize)
        {
            _maxUIUpdatesPerFrame = batchSize;
        }

        /// <summary>
        /// Set UI pooling enabled state
        /// </summary>
        public void SetUIPoolingEnabled(bool enabled)
        {
            _enableUIPooling = enabled;
        }

        /// <summary>
        /// Set distance culling enabled state
        /// </summary>
        public void SetDistanceCullingEnabled(bool enabled)
        {
            _enableCanvasCulling = enabled;
        }

        /// <summary>
        /// Set batched updates enabled state
        /// </summary>
        public void SetBatchedUpdatesEnabled(bool enabled)
        {
            _enableBatchedUpdates = enabled;
        }

        /// <summary>
        /// Increase update interval for performance optimization
        /// </summary>
        public void IncreaseUpdateInterval(float additionalInterval)
        {
            _uiUpdateInterval += additionalInterval;
            _uiUpdateInterval = Mathf.Min(_uiUpdateInterval, 1f); // Cap at 1 second
        }

        /// <summary>
        /// Track UI component update with performance monitoring
        /// </summary>
        private void TrackUIComponentUpdate(IUIUpdatable component)
        {
            if (_performanceMonitor != null)
            {
                float startTime = Time.unscaledTime;
                bool shouldUpdate = component.ShouldUpdate();
                
                if (shouldUpdate)
                {
                    component.UpdateUI();
                }
                
                float updateTime = Time.unscaledTime - startTime;
                _performanceMonitor.TrackUIUpdate(component, updateTime, shouldUpdate);
            }
            else
            {
                if (component.ShouldUpdate())
                {
                    component.UpdateUI();
                }
            }
        }

        private void OnDestroy()
        {
            if (OptimizedInputManager.Instance != null)
            {
                OptimizedInputManager.Instance.OnMouseClick -= OnUIMouseClick;
                OptimizedInputManager.Instance.OnOptimizedMouseMove -= OnUIMouseMove;
            }

            _updateQueue?.Dispose();
        }
    }

    #region Data Structures and Components

    /// <summary>
    /// UI update types for batched processing
    /// </summary>
    public enum UIUpdateType
    {
        PlantInfo,
        Progress,
        Notification,
        Stats,
        Inventory
    }

    /// <summary>
    /// Notification types
    /// </summary>
    public enum NotificationType
    {
        Info,
        Warning,
        Error,
        Success
    }

    /// <summary>
    /// UI update request
    /// </summary>
    [System.Serializable]
    public struct UIUpdateRequest
    {
        public UIUpdateType Type;
        public string ElementId;
        public object Data;
        public float Priority;
        public float Timestamp;
    }

    /// <summary>
    /// Notification UI data
    /// </summary>
    [System.Serializable]
    public struct NotificationUI
    {
        public string Message;
        public NotificationType Type;
        public float Duration;
        public float StartTime;
    }

    /// <summary>
    /// UI performance statistics
    /// </summary>
    [System.Serializable]
    public struct UIPerformanceStats
    {
        public int UpdateCycles;
        public int UpdatesQueued;
        public int UpdatesProcessed;
        public int PanelsCreated;
        public int PanelsDestroyed;
        public int ProgressBarsCreated;
        public int NotificationsQueued;
        public int NotificationsDisplayed;
        public int RegisteredPanels;
        public int CanvasCullOperations;
        public int MouseClicks;
        public int MouseMoves;
        public float AverageUpdateTime;
    }

    /// <summary>
    /// Interface for UI updatable elements
    /// </summary>
    public interface IUIUpdatable
    {
        bool ShouldUpdate();
        void UpdateUI();
    }

    /// <summary>
    /// Base class for optimized UI panels
    /// </summary>
    public abstract class OptimizedUIPanel : MonoBehaviour
    {
        public bool IsVisible { get; protected set; }
        public abstract void Initialize();
        public abstract void UpdatePanel();
        public abstract void Cleanup();
        public abstract bool ShouldUpdate();
    }

    #endregion
}