using ProjectChimera.Core.Logging;
using ProjectChimera.Core.Updates;
using System;
using System.Collections.Generic;
using UnityEngine;
using ProjectChimera.Core;

namespace ProjectChimera.Systems.Services.SpeedTree.Performance
{
    /// <summary>
    /// SpeedTree Performance Service - Main Orchestrator
    /// Coordinates LOD, batching, culling, memory optimization, and performance metrics
    ///
    /// REFACTORED: Previously 859-line monolithic file with 5 classes
    /// Now: Modular orchestrator coordinating focused subsystems
    /// </summary>
    public class SpeedTreePerformanceService : MonoBehaviour, ITickable, ISpeedTreePerformanceService
    {
        #region Properties

        public bool IsInitialized { get; private set; }

        #endregion

        #region Private Fields

        [Header("Performance Configuration")]
        [SerializeField] private int _maxVisiblePlants = 500;
        [SerializeField] private float _cullingDistance = 100f;
        [SerializeField] private bool _enableGPUInstancing = true;
        [SerializeField] private bool _enableDynamicBatching = true;
        [SerializeField] private SpeedTreeQualityLevel _defaultQuality = SpeedTreeQualityLevel.Medium;

        [Header("LOD Settings")]
        [SerializeField] private float[] _lodDistances = { 25f, 50f, 100f, 200f };
        [SerializeField] private float[] _lodQualityMultipliers = { 1.0f, 0.8f, 0.6f, 0.3f };

        [Header("Performance Monitoring")]
        [SerializeField] private bool _enablePerformanceMonitoring = true;
        [SerializeField] private float _performanceUpdateInterval = 1.0f;
        [SerializeField] private int _targetFrameRate = 60;
        [SerializeField] private float _memoryWarningThreshold = 512f;

        // Modular subsystems
        private LODManager _lodManager;
        private BatchingManager _batchingManager;
        private CullingManager _cullingManager;
        private MemoryManager _memoryManager;

        // SpeedTree tracking
        private List<GameObject> _trackedSpeedTrees = new List<GameObject>();
        private Dictionary<GameObject, SpeedTreeRendererData> _rendererData = new Dictionary<GameObject, SpeedTreeRendererData>();

        // Camera reference
        private Camera _mainCamera;

        #endregion

        #region Events

        public event Action<SpeedTreePerformanceMetrics> OnPerformanceMetricsUpdated;
        public event Action<SpeedTreeQualityLevel> OnQualityLevelChanged;
        public event Action<float> OnMemoryUsageChanged;

        #endregion

        #region IService Implementation

        public void Initialize()
        {
            if (IsInitialized) return;

            UnityEngine.Debug.Log("Operation completed");

            // Find main camera
            _mainCamera = Camera.main;
            if (_mainCamera == null)
            {
                UnityEngine.Debug.Log("Operation completed");
                return;
            }

            // Initialize subsystems
            InitializeSubsystems();

            IsInitialized = true;
            UnityEngine.Debug.Log("Operation completed");
        }

        public void Shutdown()
        {
            if (!IsInitialized) return;

            // Clear all tracked SpeedTrees
            ClearAllSpeedTrees();

            // Shutdown subsystems
            _lodManager?.ClearLODData();
            _batchingManager?.ClearBatches();
            _cullingManager?.ClearCulling();
            _memoryManager?.OptimizeMemory();

            IsInitialized = false;
            UnityEngine.Debug.Log("Operation completed");
        }

        #endregion

        #region ITickable Implementation

        public int Priority => TickPriority.ConstructionSystem;
        public bool Enabled => enabled && IsInitialized;

        public void Tick(float deltaTime)
        {
            if (!Enabled) return;

            // Update performance monitoring
            if (_enablePerformanceMonitoring)
            {
                UpdatePerformance();
            }

            // Update memory monitoring
            _memoryManager?.MonitorMemoryUsage();

            // Update LODs for tracked SpeedTrees
            if (_lodManager != null && _mainCamera != null)
            {
                _lodManager.UpdateLODs(_trackedSpeedTrees.ToArray(), _mainCamera.transform.position);
            }

            // Update batching
            _batchingManager?.UpdateBatches();

            // Update culling
            if (_cullingManager != null && _mainCamera != null)
            {
                Plane[] frustumPlanes = GeometryUtility.CalculateFrustumPlanes(_mainCamera);
                _cullingManager.UpdateCulling(_trackedSpeedTrees.ToArray(), _mainCamera.transform.position, frustumPlanes);
            }
        }

        #endregion

        #region Public API

        /// <summary>
        /// Update performance metrics and trigger optimizations
        /// </summary>
        public void UpdatePerformance()
        {
            SpeedTreePerformanceMetrics metrics = GetPerformanceMetrics();

            // Trigger performance events
            OnPerformanceMetricsUpdated?.Invoke(metrics);
            OnMemoryUsageChanged?.Invoke(metrics.MemoryUsageMB);

            // Auto quality adjustment
            if (metrics.AverageFrameTime > 33f) // Less than 30 FPS
            {
                SetQualityLevel(SpeedTreeQualityLevel.Low);
            }
            else if (metrics.AverageFrameTime < 16f && metrics.CurrentQuality < SpeedTreeQualityLevel.Ultra) // More than 60 FPS
            {
                SetQualityLevel(metrics.CurrentQuality + 1);
            }
        }

        /// <summary>
        /// Get current performance metrics
        /// </summary>
        public SpeedTreePerformanceMetrics GetPerformanceMetrics()
        {
            var metrics = new SpeedTreePerformanceMetrics(DateTime.Now)
            {
                VisiblePlants = _cullingManager?.GetVisibleCount() ?? 0,
                CurrentQuality = _defaultQuality
            };

            // Get frame time from Unity
            metrics.AverageFrameTime = Time.deltaTime * 1000f;
            metrics.PeakFrameTime = metrics.AverageFrameTime; // Simplified

            // Get memory usage
            var memoryStats = _memoryManager?.GetMemoryStats();
            if (memoryStats != null)
            {
                metrics.MemoryUsageMB = memoryStats.TotalMB;
            }

            // Get rendering stats (simplified)
            metrics.DrawCalls = _trackedSpeedTrees.Count;
            metrics.Triangles = metrics.DrawCalls * 1000; // Rough estimate
            metrics.Batches = _batchingManager?.GetBatchCount() ?? 0;

            return metrics;
        }

        /// <summary>
        /// Set quality level for all SpeedTree rendering
        /// </summary>
        public void SetQualityLevel(SpeedTreeQualityLevel level)
        {
            if (_defaultQuality == level) return;

            _defaultQuality = level;
            OnQualityLevelChanged?.Invoke(level);

            // Apply quality settings to all subsystems
            ApplyQualitySettings(level);

            UnityEngine.Debug.Log("Operation completed");
        }

        /// <summary>
        /// Optimize for maximum distance (reduce quality for better performance)
        /// </summary>
        public void OptimizeForDistance(float maxDistance)
        {
            _cullingManager?.SetCullingDistance(maxDistance);
            _lodManager?.SetLODDistances(new float[] { maxDistance * 0.25f, maxDistance * 0.5f, maxDistance * 0.75f, maxDistance });

            UnityEngine.Debug.Log("Operation completed");
        }

        /// <summary>
        /// Optimize for specific quality level
        /// </summary>
        public void OptimizeForQuality(SpeedTreeQualityLevel quality)
        {
            SetQualityLevel(quality);
        }

        /// <summary>
        /// Force garbage collection
        /// </summary>
        public void ForceGC()
        {
            _memoryManager?.ForceGC();
        }

        /// <summary>
        /// Clear cache and reset performance data
        /// </summary>
        public void ClearCache()
        {
            _batchingManager?.ClearBatches();
            _cullingManager?.ClearCulling();
            _memoryManager?.OptimizeMemory();

            UnityEngine.Debug.Log("Operation completed");
        }

        /// <summary>
        /// Add a SpeedTree for performance tracking
        /// </summary>
        public void AddSpeedTree(GameObject speedTree)
        {
            if (speedTree == null || _trackedSpeedTrees.Contains(speedTree)) return;

            _trackedSpeedTrees.Add(speedTree);

            // Track with subsystems
            _lodManager?.AddSpeedTree(speedTree);
            _cullingManager?.AddSpeedTree(speedTree);

            // Track assets for memory management
            TrackSpeedTreeAssets(speedTree);

            UnityEngine.Debug.Log("Operation completed");
        }

        /// <summary>
        /// Remove a SpeedTree from performance tracking
        /// </summary>
        public void RemoveSpeedTree(GameObject speedTree)
        {
            if (speedTree == null || !_trackedSpeedTrees.Contains(speedTree)) return;

            _trackedSpeedTrees.Remove(speedTree);

            // Remove from subsystems
            _lodManager?.RemoveSpeedTree(speedTree);
            _cullingManager?.RemoveSpeedTree(speedTree);
            _batchingManager?.RemoveFromBatch(speedTree);

            _rendererData.Remove(speedTree);

            UnityEngine.Debug.Log("Operation completed");
        }

        /// <summary>
        /// Get performance summary string
        /// </summary>
        public string GetPerformanceSummary()
        {
            var metrics = GetPerformanceMetrics();

            return $"SpeedTree Performance:\n" +
                   $"- Visible Plants: {metrics.VisiblePlants}\n" +
                   $"- Average Frame Time: {metrics.AverageFrameTime:F2}ms\n" +
                   $"- Memory Usage: {metrics.MemoryUsageMB:F1}MB\n" +
                   $"- Draw Calls: {metrics.DrawCalls}\n" +
                   $"- Batches: {metrics.Batches}\n" +
                   $"- Quality Level: {_defaultQuality}";
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Initialize all subsystems
        /// </summary>
        private void InitializeSubsystems()
        {
            // Initialize LOD manager
            var lodConfig = new SpeedTreeLODConfig(_lodDistances, _lodQualityMultipliers);
            _lodManager = new LODManager();
            _lodManager.Initialize(lodConfig);

            // Initialize batching manager
            SpeedTreeBatchingMethod batchingMethod = _enableGPUInstancing ?
                SpeedTreeBatchingMethod.GPUInstancing :
                (_enableDynamicBatching ? SpeedTreeBatchingMethod.DynamicBatching : SpeedTreeBatchingMethod.None);

            _batchingManager = new BatchingManager();
            _batchingManager.Initialize(batchingMethod);

            // Initialize culling manager
            _cullingManager = new CullingManager();
            _cullingManager.Initialize(SpeedTreeCullingStrategy.Hybrid, _cullingDistance);

            // Initialize memory manager
            _memoryManager = new MemoryManager();
            _memoryManager.Initialize(_memoryWarningThreshold);

            // Wire subsystem events
            WireSubsystemEvents();
        }

        /// <summary>
        /// Wire events between subsystems
        /// </summary>
        private void WireSubsystemEvents()
        {
            _memoryManager.OnMemoryUsageChanged += (memory) => OnMemoryUsageChanged?.Invoke(memory);
        }

        /// <summary>
        /// Apply quality settings to all subsystems
        /// </summary>
        private void ApplyQualitySettings(SpeedTreeQualityLevel level)
        {
            float qualityMultiplier = GetQualityMultiplier(level);

            // Adjust LOD distances based on quality
            float[] adjustedDistances = new float[_lodDistances.Length];
            for (int i = 0; i < _lodDistances.Length; i++)
            {
                adjustedDistances[i] = _lodDistances[i] * qualityMultiplier;
            }
            _lodManager?.SetLODDistances(adjustedDistances);

            // Adjust culling distance
            _cullingManager?.SetCullingDistance(_cullingDistance * qualityMultiplier);

            // Adjust batching settings
            _batchingManager.EnableGPUInstancing = level >= SpeedTreeQualityLevel.Medium;
            _batchingManager.EnableDynamicBatching = level >= SpeedTreeQualityLevel.Low;
        }

        /// <summary>
        /// Get quality multiplier for a quality level
        /// </summary>
        private float GetQualityMultiplier(SpeedTreeQualityLevel level)
        {
            switch (level)
            {
                case SpeedTreeQualityLevel.Ultra: return 1.0f;
                case SpeedTreeQualityLevel.High: return 0.9f;
                case SpeedTreeQualityLevel.Medium: return 0.7f;
                case SpeedTreeQualityLevel.Low: return 0.5f;
                case SpeedTreeQualityLevel.Minimal: return 0.3f;
                default: return 0.7f;
            }
        }

        /// <summary>
        /// Track assets used by a SpeedTree for memory management
        /// </summary>
        private void TrackSpeedTreeAssets(GameObject speedTree)
        {
            if (_memoryManager == null) return;

            // Track renderer and materials
            Renderer renderer = speedTree.GetComponent<Renderer>();
            if (renderer != null)
            {
                _memoryManager.TrackMaterial(renderer.sharedMaterial);

                // Track textures used by material
                foreach (string textureName in renderer.sharedMaterial.GetTexturePropertyNames())
                {
                    Texture texture = renderer.sharedMaterial.GetTexture(textureName);
                    if (texture != null)
                    {
                        _memoryManager.TrackTexture(texture);
                    }
                }
            }

            // Track mesh
            MeshFilter meshFilter = speedTree.GetComponent<MeshFilter>();
            if (meshFilter != null && meshFilter.sharedMesh != null)
            {
                _memoryManager.TrackMesh(meshFilter.sharedMesh);
            }
        }

        /// <summary>
        /// Clear all tracked SpeedTrees
        /// </summary>
        private void ClearAllSpeedTrees()
        {
            foreach (GameObject speedTree in _trackedSpeedTrees.ToArray())
            {
                RemoveSpeedTree(speedTree);
            }

            _trackedSpeedTrees.Clear();
            UnityEngine.Debug.Log("Operation completed");
        }

        #endregion

        #region Unity Lifecycle

        private void OnDestroy()
        {
            Shutdown();
        }

        #endregion
    }
}
