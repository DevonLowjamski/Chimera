using System;
using System.Collections.Generic;
using UnityEngine;
using ProjectChimera.Data.Genetics;
using ProjectChimera.Data.Shared;
using ProjectChimera.Core.Logging;

namespace ProjectChimera.Systems.Cultivation
{
    /// <summary>
    /// Core data structures and types for the Plant Update Processing system.
    /// Contains internal classes, performance metrics, and supporting data types.
    /// </summary>

    /// <summary>
    /// Minimal local stub to decouple from genetics stress types during early phase
    /// </summary>
    [System.Serializable]
    internal class StressResponse
    {
        public float OverallStressLevel { get; set; }
        public float AdaptiveCapacity { get; set; }
        public List<StressFactor> ActiveStresses { get; set; } = new List<StressFactor>();

        /// <summary>
        /// Check if the stress response indicates significant stress
        /// </summary>
        public bool HasSignificantStress => OverallStressLevel > 0.3f;

        /// <summary>
        /// Check if the plant has good adaptive capacity
        /// </summary>
        public bool HasGoodAdaptiveCapacity => AdaptiveCapacity > 0.7f;

        /// <summary>
        /// Get the most severe stress factor
        /// </summary>
        public StressFactor GetMostSevereStress()
        {
            StressFactor mostSevere = null;
            float maxSeverity = 0f;

            foreach (var stress in ActiveStresses)
            {
                if (stress.Severity > maxSeverity)
                {
                    maxSeverity = stress.Severity;
                    mostSevere = stress;
                }
            }

            return mostSevere;
        }
    }

    /// <summary>
    /// Represents a specific stress factor affecting the plant
    /// </summary>
    [System.Serializable]
    public class StressFactor
    {
        public object StressType { get; set; }
        public float Severity { get; set; }
        public float Duration { get; set; }
        public bool IsAcute { get; set; } // True for sudden stress, false for chronic

        /// <summary>
        /// Stress multiplier for damage calculation
        /// </summary>
        public float StressMultiplier { get; set; } = 1f;

        /// <summary>
        /// Damage per second for this stress factor
        /// </summary>
        public float DamagePerSecond { get; set; } = 0.01f;

        /// <summary>
        /// Get stress type name for processing
        /// </summary>
        public string GetStressTypeName()
        {
            return StressType?.ToString() ?? "Unknown";
        }

        /// <summary>
        /// Check if this stress factor is biotic (disease/pest related)
        /// </summary>
        public bool IsBiotic()
        {
            var typeName = GetStressTypeName();
            return typeName.Contains("Disease") || typeName.Contains("Pest") || typeName.Contains("Biotic");
        }

        /// <summary>
        /// Check if this is a critical stress level
        /// </summary>
        public bool IsCritical => Severity > 0.8f;
    }

    /// <summary>
    /// Active stressor affecting plant health
    /// </summary>
    [System.Serializable]
    public class ActiveStressor
    {
        public bool IsActive { get; set; } = true;
        public float Intensity { get; set; }
        public object StressSource { get; set; }
        public float StartTime { get; set; }
        public float Duration { get; set; }

        /// <summary>
        /// Check if the stressor has been active for a significant duration
        /// </summary>
        public bool IsChronic => Duration > 300f; // 5 minutes

        /// <summary>
        /// Get the current severity based on intensity and duration
        /// </summary>
        public float GetCurrentSeverity()
        {
            float stressMultiplier = 1f;

            // Try to get stress multiplier from different possible types
            if (StressSource is StressFactor stressFactor)
            {
                stressMultiplier = stressFactor.StressMultiplier;
            }
            else if (StressSource is ProjectChimera.Data.Simulation.EnvironmentalStressSO environmentalStress)
            {
                stressMultiplier = environmentalStress.StressMultiplier;
            }

            float baseSeverity = Intensity * stressMultiplier;

            // Chronic stress becomes more severe over time
            if (IsChronic)
            {
                float chronicMultiplier = 1f + (Duration - 300f) / 600f; // +50% after 10 minutes
                baseSeverity *= Mathf.Clamp(chronicMultiplier, 1f, 1.5f);
            }

            return Mathf.Clamp01(baseSeverity);
        }
    }

    /// <summary>
    /// Source of stress affecting plant health
    /// </summary>
    [System.Serializable]
    public class StressSource
    {
        public object StressType { get; set; }
        public float DamagePerSecond { get; set; }
        public float StressMultiplier { get; set; } = 1f;
        public string Description { get; set; }

        /// <summary>
        /// Check if this is a biotic stress source
        /// </summary>
        public bool IsBiotic()
        {
            var typeName = StressType?.ToString() ?? "";
            return typeName.Contains("Biotic") || typeName.Contains("Disease") || typeName.Contains("Pest");
        }

        /// <summary>
        /// Check if this is an abiotic stress source
        /// </summary>
        public bool IsAbiotic()
        {
            var typeName = StressType?.ToString() ?? "";
            return typeName.Contains("Abiotic") || typeName.Contains("Temperature") ||
                   typeName.Contains("Light") || typeName.Contains("Water") || typeName.Contains("Nutrient");
        }
    }

    /// <summary>
    /// Performance metrics for genetic calculations
    /// </summary>
    [System.Serializable]
    public class GeneticPerformanceStats
    {
        public int TotalCalculations { get; set; }
        public double AverageCalculationTimeMs { get; set; }
        public double CacheHitRatio { get; set; }
        public int BatchCalculations { get; set; }
        public double AverageBatchTimeMs { get; set; }
        public double AverageUpdateTimeMs { get; set; }
        public int CacheSize { get; set; }
        public DateTime LastUpdate { get; set; }

        /// <summary>
        /// Check if performance is within acceptable thresholds
        /// </summary>
        public bool IsPerformanceGood()
        {
            return AverageCalculationTimeMs < 5.0 && // Less than 5ms per calculation
                   CacheHitRatio > 0.7 && // At least 70% cache hit rate
                   AverageUpdateTimeMs < 10.0; // Less than 10ms per update
        }

        /// <summary>
        /// Get performance summary string
        /// </summary>
        public string GetPerformanceSummary()
        {
            return $"Calculations: {TotalCalculations}, Avg Time: {AverageCalculationTimeMs:F2}ms, " +
                   $"Cache Hit: {CacheHitRatio:P1}, Batch Avg: {AverageBatchTimeMs:F2}ms";
        }
    }

    /// <summary>
    /// Cannabinoid profile for harvest results
    /// </summary>
    [System.Serializable]
    public class CannabinoidProfile
    {
        public float THC { get; set; }
        public float CBD { get; set; }
        public float CBG { get; set; }
        public float CBN { get; set; }
        public float CBC { get; set; }
        public float THCA { get; set; }
        public float CBDA { get; set; }

        /// <summary>
        /// Get total cannabinoid content
        /// </summary>
        public float GetTotalCannabinoids()
        {
            return THC + CBD + CBG + CBN + CBC + THCA + CBDA;
        }

        /// <summary>
        /// Get THC to CBD ratio
        /// </summary>
        public float GetTHCToCBDRatio()
        {
            return CBD > 0f ? THC / CBD : float.MaxValue;
        }

        /// <summary>
        /// Classify the cannabinoid profile
        /// </summary>
        public string GetProfileType()
        {
            float ratio = GetTHCToCBDRatio();

            if (THC > 0.15f && CBD < 0.05f) return "THC Dominant";
            if (CBD > 0.15f && THC < 0.05f) return "CBD Dominant";
            if (ratio >= 0.5f && ratio <= 2f) return "Balanced";
            if (THC < 0.05f && CBD < 0.05f) return "Low Potency";

            return "Mixed Profile";
        }
    }

    /// <summary>
    /// Terpene profile for harvest results
    /// </summary>
    [System.Serializable]
    public class TerpeneProfile
    {
        public float Myrcene { get; set; }
        public float Limonene { get; set; }
        public float Pinene { get; set; }
        public float Linalool { get; set; }
        public float Caryophyllene { get; set; }
        public float Humulene { get; set; }
        public float Terpinolene { get; set; }
        public float Ocimene { get; set; }

        /// <summary>
        /// Get total terpene content
        /// </summary>
        public float GetTotalTerpenes()
        {
            return Myrcene + Limonene + Pinene + Linalool +
                   Caryophyllene + Humulene + Terpinolene + Ocimene;
        }

        /// <summary>
        /// Get dominant terpene
        /// </summary>
        public string GetDominantTerpene()
        {
            var terpenes = new Dictionary<string, float>
            {
                { "Myrcene", Myrcene },
                { "Limonene", Limonene },
                { "Pinene", Pinene },
                { "Linalool", Linalool },
                { "Caryophyllene", Caryophyllene },
                { "Humulene", Humulene },
                { "Terpinolene", Terpinolene },
                { "Ocimene", Ocimene }
            };

            string dominant = "None";
            float maxValue = 0f;

            foreach (var kvp in terpenes)
            {
                if (kvp.Value > maxValue)
                {
                    maxValue = kvp.Value;
                    dominant = kvp.Key;
                }
            }

            return maxValue > 0.01f ? dominant : "None";
        }

        /// <summary>
        /// Get aroma profile based on terpenes
        /// </summary>
        public string GetAromaProfile()
        {
            string dominant = GetDominantTerpene();

            return dominant switch
            {
                "Myrcene" => "Earthy, Musky",
                "Limonene" => "Citrus, Fresh",
                "Pinene" => "Pine, Fresh",
                "Linalool" => "Floral, Sweet",
                "Caryophyllene" => "Spicy, Peppery",
                "Humulene" => "Woody, Earthy",
                "Terpinolene" => "Floral, Herbal",
                "Ocimene" => "Sweet, Herbaceous",
                _ => "Complex Profile"
            };
        }
    }

    /// <summary>
    /// Phenotypic traits affecting plant characteristics
    /// </summary>
    [System.Serializable]
    public class PhenotypicTraits
    {
        public float YieldMultiplier { get; set; } = 1f;
        public float PotencyMultiplier { get; set; } = 1f;
        public float GrowthRateMultiplier { get; set; } = 1f;
        public float DiseaseResistance { get; set; } = 1f;
        public float FloweringTime { get; set; } = 60f; // Days
        public float StretchFactor { get; set; } = 1f;
        public float BudDensity { get; set; } = 1f;
        public float TrichromeProduction { get; set; } = 1f;
        public float PlantHeight { get; set; } = 1f; // meters
        public float HeatTolerance { get; set; } = 1f;
        public float ColdTolerance { get; set; } = 1f;
        public float DroughtTolerance { get; set; } = 1f;
        public float QualityMultiplier { get; set; } = 1f;

        /// <summary>
        /// Calculate overall plant quality based on traits
        /// </summary>
        public float GetOverallQuality()
        {
            float qualityScore = (YieldMultiplier + PotencyMultiplier + DiseaseResistance +
                                 BudDensity + TrichromeProduction) / 5f;

            return Mathf.Clamp01(qualityScore);
        }

        /// <summary>
        /// Get trait category (Indica-dominant, Sativa-dominant, or Hybrid)
        /// </summary>
        public string GetTraitCategory()
        {
            // Simple classification based on flowering time and stretch factor
            if (FloweringTime < 55f && StretchFactor < 0.8f)
                return "Indica-Dominant";
            else if (FloweringTime > 70f && StretchFactor > 1.2f)
                return "Sativa-Dominant";
            else
                return "Hybrid";
        }

        /// <summary>
        /// Check if traits indicate a premium cultivar
        /// </summary>
        public bool IsPremiumCultivar()
        {
            return YieldMultiplier > 1.2f && PotencyMultiplier > 1.2f &&
                   DiseaseResistance > 0.8f && TrichromeProduction > 1.1f;
        }
    }

    /// <summary>
    /// Configuration options for plant update processing
    /// </summary>
    [System.Serializable]
    public class PlantUpdateConfiguration
    {
        public bool EnableStressSystem { get; set; } = true;
        public bool EnableGxEInteractions { get; set; } = true;
        public bool EnableAdvancedGenetics { get; set; } = true;
        public bool EnablePerformanceOptimization { get; set; } = true;
        public float CacheUpdateInterval { get; set; } = 5f; // Seconds
        public int MaxCacheSize { get; set; } = 1000;
        public float StressThreshold { get; set; } = 0.3f;
        public float AdaptationRate { get; set; } = 0.1f;

        /// <summary>
        /// Create default configuration
        /// </summary>
        public static PlantUpdateConfiguration CreateDefault()
        {
            return new PlantUpdateConfiguration();
        }

        /// <summary>
        /// Create high-performance configuration
        /// </summary>
        public static PlantUpdateConfiguration CreateHighPerformance()
        {
            return new PlantUpdateConfiguration
            {
                EnableStressSystem = true,
                EnableGxEInteractions = false, // Disable for better performance
                EnableAdvancedGenetics = false, // Disable for better performance
                EnablePerformanceOptimization = true,
                CacheUpdateInterval = 10f, // Longer intervals
                MaxCacheSize = 500 // Smaller cache
            };
        }

        /// <summary>
        /// Create maximum quality configuration
        /// </summary>
        public static PlantUpdateConfiguration CreateMaxQuality()
        {
            return new PlantUpdateConfiguration
            {
                EnableStressSystem = true,
                EnableGxEInteractions = true,
                EnableAdvancedGenetics = true,
                EnablePerformanceOptimization = false, // Prioritize accuracy over speed
                CacheUpdateInterval = 1f, // Frequent updates
                MaxCacheSize = 2000, // Larger cache
                AdaptationRate = 0.05f // Slower, more realistic adaptation
            };
        }
    }

    /// <summary>
    /// Update statistics for monitoring system performance
    /// </summary>
    [System.Serializable]
    public class UpdateStatistics
    {
        public int TotalUpdates { get; set; }
        public int SuccessfulUpdates { get; set; }
        public int FailedUpdates { get; set; }
        public double AverageUpdateTime { get; set; }
        public double MaxUpdateTime { get; set; }
        public DateTime LastUpdate { get; set; }
        public int ActivePlants { get; set; }
        public int ProcessedBatches { get; set; }

        /// <summary>
        /// Get success rate percentage
        /// </summary>
        public double GetSuccessRate()
        {
            return TotalUpdates > 0 ? (double)SuccessfulUpdates / TotalUpdates * 100.0 : 0.0;
        }

        /// <summary>
        /// Reset statistics
        /// </summary>
        public void Reset()
        {
            TotalUpdates = 0;
            SuccessfulUpdates = 0;
            FailedUpdates = 0;
            AverageUpdateTime = 0.0;
            MaxUpdateTime = 0.0;
            ActivePlants = 0;
            ProcessedBatches = 0;
            LastUpdate = DateTime.Now;
        }

        /// <summary>
        /// Record a successful update
        /// </summary>
        public void RecordUpdate(double updateTime, bool success)
        {
            TotalUpdates++;
            if (success)
                SuccessfulUpdates++;
            else
                FailedUpdates++;

            // Update running average
            AverageUpdateTime = (AverageUpdateTime * (TotalUpdates - 1) + updateTime) / TotalUpdates;

            if (updateTime > MaxUpdateTime)
                MaxUpdateTime = updateTime;

            LastUpdate = DateTime.Now;
        }
    }
}
