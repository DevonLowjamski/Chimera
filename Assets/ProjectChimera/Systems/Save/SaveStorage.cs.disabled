using ProjectChimera.Core.Logging;
using UnityEngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Linq;
using ProjectChimera.Data.Save;
using ProjectChimera.Core;
using ProjectChimera.Core.Updates;
using ProjectChimera.Systems.Save.Components;
using ProjectChimera.Systems.Save.Storage;
using System.IO.Compression;
using CloudSyncResult = ProjectChimera.Data.Save.CloudSyncResult;
using CloudStorageProviderEnum = ProjectChimera.Systems.Save.Storage.CloudStorageProvider;
using GoogleDriveProvider = ProjectChimera.Systems.Save.Storage.GoogleDriveProvider;
using DropboxProvider = ProjectChimera.Systems.Save.Storage.DropboxProvider;
using OneDriveProvider = ProjectChimera.Systems.Save.Storage.OneDriveProvider;
using iCloudProvider = ProjectChimera.Systems.Save.Storage.iCloudProvider;
using CustomCloudProvider = ProjectChimera.Systems.Save.Storage.CustomCloudProvider;
using SaveCore = ProjectChimera.Systems.Save.Storage.SaveCore;
using LoadCore = ProjectChimera.Systems.Save.Storage.LoadCore;

// Type alias to resolve CompressionLevel ambiguity
using CompressionLevel = System.IO.Compression.CompressionLevel;

namespace ProjectChimera.Systems.Save
{
    /// <summary>
    /// Comprehensive save system storage for Project Chimera
    /// Handles save/load operations, cloud sync, backup management, and data validation
    /// </summary>
    public class SaveStorage : MonoBehaviour, ITickable
    {
        [Header("Save Configuration")]
        [SerializeField] private string _saveDirectory = "Saves";
        [SerializeField] private string _backupDirectory = "Backups";
        [SerializeField] private string _cloudSyncDirectory = "CloudSync";
        [SerializeField] private bool _enableCloudSync = false;
        [SerializeField] private bool _enableCompression = true;
        [SerializeField] private bool _enableEncryption = false;
        [SerializeField] private bool _enableBackups = true;
        [SerializeField] private int _maxBackupsPerSlot = 5;
        [SerializeField] private float _autoSaveInterval = 300f; // 5 minutes

        [Header("Cloud Configuration")]
        [SerializeField] private CloudStorageProviderEnum _cloudProvider = CloudStorageProviderEnum.None;
        [SerializeField] private bool _enableAutoSync = false;
        [SerializeField] private float _syncInterval = 600f; // 10 minutes

        // Core services
        private ISaveCore _saveCore;
        private ILoadCore _loadCore;
        private IMigrationService _migrationService;
        private ISerializationHelpers _serializationHelpers;

        // Cloud storage
        private ProjectChimera.Systems.Save.Storage.ICloudStorageProvider _cloudStorageProvider;
        private ProjectChimera.Data.Save.CloudSyncStatusType _cloudSyncStatus = ProjectChimera.Data.Save.CloudSyncStatusType.NotConnected;

        // Internal state
        private bool _isInitialized = false;
        private float _lastAutoSaveTime = 0f;
        private float _lastSyncTime = 0f;
        private Dictionary<string, DateTime> _slotLastSaved = new Dictionary<string, DateTime>();

        public event System.Action<string, bool> OnSaveCompleted;
        public event System.Action<string, bool> OnLoadCompleted;
        public event System.Action<ProjectChimera.Data.Save.CloudSyncStatusType> OnCloudSyncStatusChanged;

        private void Awake()
        {
            InitializeSystem();
        }

        private void Start()
        {
            if (_enableCloudSync)
            {
                InitializeCloudSync();
            }
            
            // Register with UpdateOrchestrator
            UpdateOrchestrator.Instance?.RegisterTickable(this);
        }

        // ITickable implementation
        public int TickPriority => TickPriority.SaveSystem;
        public bool IsTickable => enabled && gameObject.activeInHierarchy;
        
        public void Tick(float deltaTime)
        {
            if (!_isInitialized) return;

            // Auto-save logic
            if (_lastAutoSaveTime + _autoSaveInterval < Time.time)
            {
                // Implement auto-save logic here
                _lastAutoSaveTime = Time.time;
            }

            // Auto-sync logic
            if (_enableCloudSync && _enableAutoSync && _lastSyncTime + _syncInterval < Time.time)
            {
                // Implement auto-sync logic here
                _lastSyncTime = Time.time;
            }
        }
        
        public void OnRegistered()
        {
            // Called when registered with UpdateOrchestrator
        }
        
        public void OnUnregistered()
        {
            // Called when unregistered from UpdateOrchestrator
        }

        private void InitializeSystem()
        {
            try
            {
                // Initialize core services
                _saveCore = new SaveCore() as ISaveCore;
                _loadCore = new LoadCore() as ILoadCore;
                _migrationService = new MigrationService(_saveCore, _loadCore);
                _serializationHelpers = new SerializationHelpers();

                // Initialize core services
                _saveCore.Initialize(_saveDirectory, _backupDirectory, Path.Combine(_saveDirectory, "archive"));
                _loadCore.Initialize(_saveDirectory, _backupDirectory, Path.Combine(_saveDirectory, "archive"));

                _isInitialized = true;
                ChimeraLogger.Log("OTHER", "$1", this);
            }
            catch (Exception ex)
            {
                ChimeraLogger.Log("OTHER", "$1", this);
            }
        }

        private async void InitializeCloudSync()
        {
            try
            {
                _cloudStorageProvider = CreateCloudProvider(_cloudProvider);
                if (_cloudStorageProvider != null)
                {
                    bool connected = await _cloudStorageProvider.Initialize();
                    _cloudSyncStatus = connected ? ProjectChimera.Data.Save.CloudSyncStatusType.Connected : ProjectChimera.Data.Save.CloudSyncStatusType.Error;
                    OnCloudSyncStatusChanged?.Invoke(_cloudSyncStatus);

                    ChimeraLogger.Log("OTHER", "$1", this);
                }
            }
            catch (Exception ex)
            {
                _cloudSyncStatus = ProjectChimera.Data.Save.CloudSyncStatusType.Error;
                OnCloudSyncStatusChanged?.Invoke(_cloudSyncStatus);
                ChimeraLogger.Log("OTHER", "$1", this);
            }
        }

        /// <summary>
        /// Save game data to specified slot
        /// </summary>
        public async Task<bool> SaveGameAsync(string slotName, object gameData)
        {
            if (!_isInitialized)
            {
                LogError("Save system not initialized");
                return false;
            }

            try
            {
                // Serialize data
                byte[] serializedData = await _serializationHelpers.SerializeDataAsync(gameData);

                // Save to disk
                var result = await _saveCore.WriteFileAsync(slotName, serializedData);

                if (result.Success)
                {
                    _slotLastSaved[slotName] = DateTime.UtcNow;
                    OnSaveCompleted?.Invoke(slotName, true);
                    LogInfo($"Successfully saved game to slot: {slotName}");

                    // Cloud sync if enabled
                    if (_enableCloudSync && _cloudSyncStatus == ProjectChimera.Data.Save.CloudSyncStatusType.Connected)
                    {
                        _ = SyncToCloudAsync(slotName, serializedData);
                    }

                    return true;
                }
                else
                {
                    OnSaveCompleted?.Invoke(slotName, false);
                    LogError($"Failed to save game to slot {slotName}: {result.Message}");
                    return false;
                }
            }
            catch (Exception ex)
            {
                OnSaveCompleted?.Invoke(slotName, false);
                LogError($"Exception during save operation for slot {slotName}: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Load game data from specified slot
        /// </summary>
        public async Task<T> LoadGameAsync<T>(string slotName) where T : class
        {
            if (!_isInitialized)
            {
                LogError("Save system not initialized");
                OnLoadCompleted?.Invoke(slotName, false);
                return null;
            }

            try
            {
                // Load from disk
                var result = await _loadCore.ReadFileAsync(slotName);

                if (result.Success && result.Data != null)
                {
                    // Deserialize data
                    T gameData = await _serializationHelpers.DeserializeDataAsync<T>(result.Data);

                    OnLoadCompleted?.Invoke(slotName, true);
                    LogInfo($"Successfully loaded game from slot: {slotName}");
                    return gameData;
                }
                else
                {
                    OnLoadCompleted?.Invoke(slotName, false);
                    LogError($"Failed to load game from slot {slotName}: {result.Message}");
                    return null;
                }
            }
            catch (Exception ex)
            {
                OnLoadCompleted?.Invoke(slotName, false);
                LogError($"Exception during load operation for slot {slotName}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Get list of available save slots
        /// </summary>
        public List<string> GetSaveSlots()
        {
            if (!_isInitialized) return new List<string>();

            try
            {
                var saveDirectory = Path.Combine(Application.persistentDataPath, _saveDirectory);
                if (!Directory.Exists(saveDirectory)) return new List<string>();

                return Directory.GetFiles(saveDirectory, "*.save")
                    .Select(Path.GetFileNameWithoutExtension)
                    .OrderByDescending(slot => _slotLastSaved.ContainsKey(slot) ? _slotLastSaved[slot] : DateTime.MinValue)
                    .ToList();
            }
            catch (Exception ex)
            {
                LogError($"Failed to get save slots: {ex.Message}");
                return new List<string>();
            }
        }

        /// <summary>
        /// Delete a save slot
        /// </summary>
        public async Task<bool> DeleteSaveSlotAsync(string slotName)
        {
            if (!_isInitialized) return false;

            try
            {
                var result = await _saveCore.DeleteFileAsync(slotName);
                if (result.Success)
                {
                    _slotLastSaved.Remove(slotName);
                    LogInfo($"Successfully deleted save slot: {slotName}");
                }
                return result.Success;
            }
            catch (Exception ex)
            {
                LogError($"Failed to delete save slot {slotName}: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Create backup of save slot
        /// </summary>
        public async Task<bool> CreateBackupAsync(string slotName)
        {
            if (!_isInitialized || !_enableBackups) return false;

            try
            {
                var result = await _migrationService.CreateBackupAsync(slotName);
                LogInfo($"Backup creation for {slotName}: {(result.Success ? "Success" : result.Message)}");
                return result.Success;
            }
            catch (Exception ex)
            {
                LogError($"Failed to create backup for {slotName}: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Sync save data to cloud
        /// </summary>
        private async Task SyncToCloudAsync(string slotName, byte[] data)
        {
            if (_cloudStorageProvider == null || _cloudSyncStatus != ProjectChimera.Data.Save.CloudSyncStatusType.Connected) return;

            try
            {
                _cloudSyncStatus = ProjectChimera.Data.Save.CloudSyncStatusType.Syncing;
                OnCloudSyncStatusChanged?.Invoke(_cloudSyncStatus);

                var result = await _cloudStorageProvider.UploadAsync($"{slotName}.save", data);

                _cloudSyncStatus = result.Success ? ProjectChimera.Data.Save.CloudSyncStatusType.Synced : ProjectChimera.Data.Save.CloudSyncStatusType.Error;
                OnCloudSyncStatusChanged?.Invoke(_cloudSyncStatus);

                if (result.Success)
                {
                    LogInfo($"Successfully synced {slotName} to cloud");
                }
                else
                {
                    LogError($"Failed to sync {slotName} to cloud: {result.Message}");
                }
            }
            catch (Exception ex)
            {
                _cloudSyncStatus = ProjectChimera.Data.Save.CloudSyncStatusType.Error;
                OnCloudSyncStatusChanged?.Invoke(_cloudSyncStatus);
                LogError($"Cloud sync error for {slotName}: {ex.Message}");
            }
        }

        private ProjectChimera.Systems.Save.Storage.ICloudStorageProvider CreateCloudProvider(CloudStorageProviderEnum provider)
        {
            return provider switch
            {
                CloudStorageProviderEnum.GoogleDrive => new GoogleDriveProvider(),
                CloudStorageProviderEnum.Dropbox => new DropboxProvider(),
                CloudStorageProviderEnum.OneDrive => new OneDriveProvider(),
                CloudStorageProviderEnum.iCloud => new iCloudProvider(),
                CloudStorageProviderEnum.Custom => new CustomCloudProvider(),
                _ => null
            };
        }

        private void LogInfo(string message)
        {
            ChimeraLogger.Log("OTHER", "$1", this);
        }

        private void LogWarning(string message)
        {
            ChimeraLogger.Log("OTHER", "$1", this);
        }

        private void LogError(string message)
        {
            ChimeraLogger.Log("OTHER", "$1", this);
        }

        public ISaveCore GetSaveCore() => _saveCore;

        // File operations
        public async Task<ProjectChimera.Data.Save.StorageResult> WriteFileAsync(string fileName, byte[] data, bool createBackup = false)
        {
            if (!_isInitialized) return ProjectChimera.Data.Save.StorageResult.CreateFailure("SaveStorage not initialized");
            return await _saveCore.WriteFileAsync(fileName, data);
        }

        public async Task<ProjectChimera.Data.Save.StorageDataResult> ReadFileAsync(string fileName)
        {
            if (!_isInitialized) return ProjectChimera.Data.Save.StorageDataResult.CreateFailure("SaveStorage not initialized");
            return await _loadCore.ReadFileAsync(fileName);
        }

        public async Task<ProjectChimera.Data.Save.StorageResult> DeleteFileAsync(string fileName)
        {
            if (!_isInitialized) return ProjectChimera.Data.Save.StorageResult.CreateFailure("SaveStorage not initialized");
            return await _saveCore.DeleteFileAsync(fileName);
        }
        public ILoadCore GetLoadCore() => _loadCore;
        public IMigrationService GetMigrationService() => _migrationService;
        public ISerializationHelpers GetSerializationHelpers() => _serializationHelpers;
        public ProjectChimera.Data.Save.CloudSyncStatusType GetCloudSyncStatus() => _cloudSyncStatus;
    }
}
