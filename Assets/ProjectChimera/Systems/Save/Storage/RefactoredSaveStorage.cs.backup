using ProjectChimera.Core.Logging;
using UnityEngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Linq;
using ProjectChimera.Data.Save;
using StorageResult = ProjectChimera.Data.Save.StorageResult;
using StorageDataResult = ProjectChimera.Data.Save.StorageDataResult;
using StorageInfo = ProjectChimera.Data.Save.StorageInfo;
using StorageMetrics = ProjectChimera.Data.Save.StorageMetrics;
using HashAlgorithmType = ProjectChimera.Data.Save.HashAlgorithmType;
using ProjectChimera.Data.Save;
using ProjectChimera.Core;
using ProjectChimera.Systems.Save.Components;
using ProjectChimera.Systems.Save.Storage;
using CloudStorageProvider = ProjectChimera.Systems.Save.Storage.CloudStorageProvider;
using CompressionAlgorithm = ProjectChimera.Systems.Save.Storage.CompressionAlgorithm;
using ICloudStorageProvider = ProjectChimera.Systems.Save.Storage.ICloudStorageProvider;
using System.IO.Compression;

// Type alias to resolve CompressionLevel ambiguity
using CompressionLevel = System.IO.Compression.CompressionLevel;

namespace ProjectChimera.Systems.Save
{
    /// <summary>
    /// Refactored Save Storage - orchestrates all storage components
    /// Maintains original interface while using modular components
    /// Refactored from monolithic 1,131-line class into focused components
    /// </summary>
    public class RefactoredSaveStorage : MonoBehaviour
    {
        [Header("Storage Configuration")]
        [SerializeField] private string _saveDirectory = "saves";
        [SerializeField] private string _backupDirectory = "backups";
        [SerializeField] private string _tempDirectory = "temp";
        [SerializeField] private string _archiveDirectory = "archive";
        [SerializeField] private string _saveFileExtension = ".save";
        [SerializeField] private string _backupFileExtension = ".backup";

        [Header("Backup Settings")]
        [SerializeField] private bool _enableAutoBackup = true;
        [SerializeField] private int _maxBackupsPerSlot = 5;
        [SerializeField] private int _maxTotalBackups = 50;
        [SerializeField] private bool _enableIncrementalBackups = true;
        [SerializeField] private TimeSpan _backupRetentionPeriod = TimeSpan.FromDays(30);

        [Header("Performance Settings")]
        [SerializeField] private bool _enableAsyncOperations = true;
        [SerializeField] private bool _enableAtomicWrites = true;
        [SerializeField] private bool _enableTransactionSupport = true;
        [SerializeField] private int _maxConcurrentOperations = 4;
        [SerializeField] private long _maxFileSize = 100 * 1024 * 1024; // 100MB

        [Header("Cloud Sync Settings")]
        [SerializeField] private bool _enableCloudSync = false;
        [SerializeField] private CloudStorageProvider _cloudProvider = CloudStorageProvider.None;
        [SerializeField] private bool _enableCloudBackup = false;
        [SerializeField] private bool _autoSyncOnSave = false;
        [SerializeField] private float _syncRetryDelay = 30f;

        [Header("Storage Optimization")]
        [SerializeField] private bool _enableStorageOptimization = true;
        [SerializeField] private bool _enableDiskSpaceMonitoring = true;
        [SerializeField] private long _minFreeSpaceBytes = 1024 * 1024 * 1024; // 1GB
        [SerializeField] private bool _enableAutoCleanup = true;
        [SerializeField] private float _cleanupThresholdPercent = 0.9f; // 90%

        [Header("Compression Settings")]
        [SerializeField] private bool _enableDataCompression = true;
        [SerializeField] private CompressionLevel _compressionLevel = CompressionLevel.Optimal;
        [SerializeField] private CompressionAlgorithm _compressionAlgorithm = CompressionAlgorithm.GZip;
        [SerializeField] private float _compressionThreshold = 0.1f;

        [Header("Validation Settings")]
        [SerializeField] private bool _enableIntegrityChecking = true;
        [SerializeField] private bool _enableCorruptionDetection = true;
        [SerializeField] private HashAlgorithmType _hashAlgorithm = HashAlgorithmType.SHA256;

        // Storage components
        private ISaveCore _saveCore;
        private ILoadCore _loadCore;
        private ISerializationHelpers _serializationHelpers;
        private IMigrationService _migrationService;

        // Cloud sync
        private ProjectChimera.Systems.Save.Storage.ICloudStorageProvider _cloudStorageProvider;
        private Dictionary<string, ProjectChimera.Data.Save.CloudSyncStatus> _cloudSyncStatus = new Dictionary<string, ProjectChimera.Data.Save.CloudSyncStatus>();

        // Storage metrics and state
        private StorageMetrics _metrics = new StorageMetrics();
        private bool _isInitialized = false;

        #region Unity Lifecycle

        private void Awake()
        {
            InitializeStorageSystem();
        }

        #endregion

        #region Initialization

        private void InitializeStorageSystem()
        {
            if (_isInitialized) return;

            try
            {
                InitializeComponents();
                ConfigureComponentIntegrations();
                InitializeAllComponents();
                InitializeCloudProvider();

                _isInitialized = true;
                LogInfo($"SaveStorage initialized - Directory: {Path.Combine(Application.persistentDataPath, _saveDirectory)}");
            }
            catch (Exception ex)
            {
                LogError($"Failed to initialize SaveStorage: {ex.Message}");
                throw;
            }
        }

        private void InitializeComponents()
        {
            // Create storage components
            _saveCore = new SaveCore() as ISaveCore;
            _serializationHelpers = new SerializationHelpers();
            _loadCore = new LoadCore(_serializationHelpers) as ILoadCore;
            _migrationService = new MigrationService(_saveCore, _loadCore);
        }

        private void ConfigureComponentIntegrations()
        {
            // Set up cross-component dependencies
            (_loadCore as LoadCore)?.SetSerializationHelpers(_serializationHelpers);
            (_migrationService as MigrationService)?.SetCoreServices(_saveCore, _loadCore);
        }

        private void InitializeAllComponents()
        {
            // Initialize all components with their specific configurations
            _saveCore.Initialize(_saveDirectory, _backupDirectory, _archiveDirectory);

            _loadCore.Initialize(_saveDirectory, _backupDirectory, _archiveDirectory);

            _serializationHelpers.Initialize(_enableDataCompression, _compressionLevel,
                _compressionAlgorithm, _enableIntegrityChecking, _hashAlgorithm);

            _migrationService.Initialize(_enableAutoBackup, _maxBackupsPerSlot, _maxTotalBackups,
                _backupRetentionPeriod, _enableCloudSync, _enableStorageOptimization,
                _minFreeSpaceBytes, _enableAutoCleanup, _cleanupThresholdPercent);

            LogInfo("All storage components initialized");
        }

        private void InitializeCloudProvider()
        {
            if (_enableCloudSync && _cloudProvider != CloudStorageProvider.None)
            {
                try
                {
                    _cloudStorageProvider = CreateCloudProvider(_cloudProvider);
                    _migrationService.SetCloudProvider(_cloudStorageProvider);
                    LogInfo($"Cloud provider initialized: {_cloudProvider}");
                }
                catch (Exception ex)
                {
                    LogError($"Failed to initialize cloud provider: {ex.Message}");
                }
            }
        }

        #endregion

        #region Public API - Core Operations

        public async Task<StorageResult> WriteFileAsync(string slotName, byte[] data, bool createBackup = true)
        {
            if (!_isInitialized)
            {
                return StorageResult.CreateFailure("SaveStorage not initialized");
            }

            try
            {
                // Process data through serialization helpers
                var processedData = await _serializationHelpers.ProcessOutgoingDataAsync(data);

                // Save through core
                var result = await _saveCore.WriteFileAsync(slotName, processedData, createBackup && _enableAutoBackup);

                // Auto-sync to cloud if enabled
                if (result.Success && _autoSyncOnSave && _enableCloudSync)
                {
                    _ = _migrationService.SyncToCloudAsync(slotName); // Fire and forget
                }

                UpdateMetrics();
                return result;
            }
            catch (Exception ex)
            {
                LogError($"Write operation failed for slot {slotName}: {ex.Message}");
                return StorageResult.CreateFailure($"Write failed: {ex.Message}");
            }
        }

        public async Task<StorageDataResult> ReadFileAsync(string slotName)
        {
            if (!_isInitialized)
            {
                return StorageDataResult.CreateFailure("SaveStorage not initialized");
            }

            try
            {
                var result = await _loadCore.ReadFileAsync(slotName);
                UpdateMetrics();
                return result;
            }
            catch (Exception ex)
            {
                LogError($"Read operation failed for slot {slotName}: {ex.Message}");
                return StorageDataResult.CreateFailure($"Read failed: {ex.Message}");
            }
        }

        public async Task<StorageResult> DeleteFileAsync(string slotName, bool deleteBackups = true)
        {
            if (!_isInitialized)
            {
                return StorageResult.CreateFailure("SaveStorage not initialized");
            }

            try
            {
                var result = await _saveCore.DeleteFileAsync(slotName, deleteBackups);

                if (result.Success && deleteBackups)
                {
                    await _migrationService.DeleteBackupsAsync(slotName);
                }

                UpdateMetrics();
                return result;
            }
            catch (Exception ex)
            {
                LogError($"Delete operation failed for slot {slotName}: {ex.Message}");
                return StorageResult.CreateFailure($"Delete failed: {ex.Message}");
            }
        }

        public async Task<StorageResult> MoveFileAsync(string fromSlotName, string toSlotName)
        {
            if (!_isInitialized)
            {
                return StorageResult.CreateFailure("SaveStorage not initialized");
            }

            return await _migrationService.MoveFileAsync(fromSlotName, toSlotName);
        }

        #endregion

        #region Transaction Support

        public async Task<StorageResult> BeginTransactionAsync(string slotName)
        {
            return await _saveCore.BeginTransactionAsync(slotName);
        }

        public async Task<StorageResult> CommitTransactionAsync(string transactionId)
        {
            return await _saveCore.CommitTransactionAsync(transactionId);
        }

        public async Task<StorageResult> RollbackTransactionAsync(string transactionId)
        {
            return await _saveCore.RollbackTransactionAsync(transactionId);
        }

        #endregion

        #region Backup Management

        public async Task<StorageResult> CreateBackupAsync(string slotName, bool incremental = false)
        {
            return await _migrationService.CreateBackupAsync(slotName, incremental);
        }

        public async Task<StorageResult> RestoreFromBackupAsync(string slotName, string backupFileName = null)
        {
            return await _migrationService.RestoreFromBackupAsync(slotName, backupFileName);
        }

        #endregion

        #region Cloud Sync

        public async Task<ProjectChimera.Data.Save.CloudSyncResult> SyncToCloudAsync(string slotName)
        {
            return await _migrationService.SyncToCloudAsync(slotName);
        }

        public async Task<ProjectChimera.Data.Save.CloudSyncResult> SyncFromCloudAsync(string slotName)
        {
            return await _migrationService.SyncFromCloudAsync(slotName);
        }

        #endregion

        #region Storage Information

        public async Task<StorageInfo> GetStorageInfoAsync(string slotName = null)
        {
            return await _loadCore.GetStorageInfoAsync(slotName ?? "default");
        }

        public async Task<StorageResult> OptimizeStorageAsync()
        {
            return await _migrationService.OptimizeStorageAsync();
        }

        public async Task<StorageResult> ForceCleanupAsync()
        {
            return await _migrationService.ForceCleanupAsync();
        }

        #endregion

        #region Helper Methods

        private void UpdateMetrics()
        {
            if (_saveCore?.Metrics != null)
            {
                _metrics = _saveCore.Metrics;
            }
        }

        private ProjectChimera.Systems.Save.Storage.ICloudStorageProvider CreateCloudProvider(CloudStorageProvider provider)
        {
            return provider switch
            {
                CloudStorageProvider.GoogleDrive => new GoogleDriveProvider(),
                CloudStorageProvider.Dropbox => new DropboxProvider(),
                CloudStorageProvider.OneDrive => new OneDriveProvider(),
                CloudStorageProvider.iCloud => new iCloudProvider(),
                CloudStorageProvider.Custom => new CustomCloudProvider(),
                _ => null
            };
        }

        private void LogInfo(string message)
        {
            UnityEngine.Debug.Log("Operation completed");
        }

        private void LogWarning(string message)
        {
            UnityEngine.Debug.Log("Operation completed");
        }

        private void LogError(string message)
        {
            UnityEngine.Debug.Log("Operation completed");
        }

        #endregion

        #region Public Properties for Backward Compatibility

        public bool IsInitialized => _isInitialized;
        public StorageMetrics Metrics => _metrics;

        #endregion

        #region Component Access (for advanced usage)

        public ISaveCore GetSaveCore() => _saveCore;
        public ILoadCore GetLoadCore() => _loadCore;
        public ISerializationHelpers GetSerializationHelpers() => _serializationHelpers;
        public IMigrationService GetMigrationService() => _migrationService;

        #endregion
    }


}
