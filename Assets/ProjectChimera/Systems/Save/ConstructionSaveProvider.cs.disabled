using ProjectChimera.Core.Logging;
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ProjectChimera.Core;
using ConstructionStateDTO = ProjectChimera.Data.Save.ConstructionStateDTO;

namespace ProjectChimera.Systems.Save
{
    /// <summary>
    /// SIMPLE: Basic construction save provider aligned with Project Chimera's save system vision.
    /// Focuses on essential construction data saving and loading without over-engineering.
    /// </summary>
    public class ConstructionSaveProvider : MonoBehaviour, ISaveSectionProvider
    {
        [Header("Basic Settings")]
        [SerializeField] private string _sectionVersion = "1.0.0";
        [SerializeField] private bool _enableSaving = true;

        // System references
        private IConstructionSystem _constructionSystem;

        // Basic state
        private ConstructionStateDTO _lastSavedState;
        private bool _isInitialized = false;

        #region ISaveSectionProvider Implementation

        public string SectionKey => SaveSectionKeys.CONSTRUCTION;
        public string SectionName => "Construction System";
        public string SectionVersion => _sectionVersion;
        public int Priority => 1;
        public bool IsRequired => false;
        public bool SupportsIncrementalSave => false;
        public long EstimatedDataSize => 0;
        public IReadOnlyList<string> Dependencies => new string[0];

        public Task<ISaveSectionData> GatherSectionDataAsync()
        {
            if (!_enableSaving)
                return Task.FromResult<ISaveSectionData>(null);

            InitializeSystemsIfNeeded();

            var constructionData = new ConstructionSectionData
            {
                SectionKey = SectionKey,
                DataVersion = SectionVersion,
                Timestamp = DateTime.Now,
                ConstructionState = GatherConstructionState()
            };

            _lastSavedState = constructionData.ConstructionState;

            ChimeraLogger.Log("SAVE", $"Construction data gathered: {constructionData.ConstructionState?.PlacedObjects?.Count ?? 0} objects");

            return Task.FromResult<ISaveSectionData>(constructionData);
        }

        public Task RestoreSectionDataAsync(ISaveSectionData sectionData)
        {
            if (!_enableSaving || sectionData == null)
                return Task.CompletedTask;

            var constructionData = sectionData as ConstructionSectionData;
            if (constructionData?.ConstructionState != null)
            {
                RestoreConstructionState(constructionData.ConstructionState);
                ChimeraLogger.Log("SAVE", "Construction data restored");
            }

            return Task.CompletedTask;
        }

        #endregion

        #region Private Methods

        private void InitializeSystemsIfNeeded()
        {
            if (_isInitialized) return;

            // Try to resolve IConstructionSystem from ServiceContainer first
            if (ServiceContainerFactory.Instance != null && ServiceContainerFactory.Instance.TryGetService<IConstructionSystem>(out var constructionService))
            {
                _constructionSystem = constructionService;
                ChimeraLogger.Log("OTHER", "$1", this);
            }
            else
            {
                // Fallback to scene discovery for IConstructionSystem
                var allManagers = UnityEngine.Object.FindObjectsOfType<MonoBehaviour>();
                foreach (var manager in allManagers)
                {
                    if (manager is IConstructionSystem foundConstructionSystem)
                    {
                        _constructionSystem = foundConstructionSystem;
                        break;
                    }
                }
                
                // Register found system in ServiceContainer for future use
                if (_constructionSystem != null && ServiceContainerFactory.Instance != null)
                {
                    ServiceContainerFactory.Instance.RegisterInstance<IConstructionSystem>(_constructionSystem);
                    ChimeraLogger.Log("OTHER", "$1", this);
                }
                else if (_constructionSystem == null)
                {
                    ChimeraLogger.Log("OTHER", "$1", this);
                }
            }

            _isInitialized = true;
        }

        private ConstructionStateDTO GatherConstructionState()
        {
            if (_constructionSystem == null)
                return new ConstructionStateDTO();

            // Simple gathering of construction state
            return _constructionSystem.GetConstructionState();
        }

        private void RestoreConstructionState(ConstructionStateDTO state)
        {
            if (_constructionSystem == null || state == null)
                return;

            // Simple restoration of construction state
            _constructionSystem.RestoreConstructionState(state);
        }

        #endregion

        #region Missing ISaveSectionProvider Interface Methods

        public async Task<SaveSectionResult> ApplySectionDataAsync(ISaveSectionData sectionData)
        {
            try
            {
                await RestoreSectionDataAsync(sectionData);
                return SaveSectionResult.CreateSuccess();
            }
            catch (System.Exception ex)
            {
                return SaveSectionResult.CreateFailure($"Failed to apply construction data: {ex.Message}", ex);
            }
        }

        public async Task<SaveSectionValidation> ValidateSectionDataAsync(ISaveSectionData sectionData)
        {
            if (sectionData == null)
                return SaveSectionValidation.CreateInvalid(new System.Collections.Generic.List<string> { "Section data is null" });

            if (!(sectionData is ConstructionSectionData))
                return SaveSectionValidation.CreateInvalid(new System.Collections.Generic.List<string> { "Invalid section data type" });

            return SaveSectionValidation.CreateValid();
        }

        public async Task<ISaveSectionData> MigrateSectionDataAsync(ISaveSectionData oldData, string fromVersion)
        {
            // Simple migration - just return the data as-is for now
            return oldData;
        }

        public SaveSectionSummary GetSectionSummary()
        {
            return new SaveSectionSummary
            {
                SectionKey = SectionKey,
                SectionName = SectionName,
                StatusDescription = "Construction system state",
                ItemCount = 1,
                DataSize = EstimatedDataSize,
                LastUpdated = System.DateTime.Now,
                KeyValuePairs = new System.Collections.Generic.Dictionary<string, string>(),
                HasErrors = false,
                ErrorMessages = new System.Collections.Generic.List<string>()
            };
        }

        public bool HasChanges()
        {
            // For simplicity, always return true
            return true;
        }

        public void MarkClean()
        {
            // Mark as clean - implementation can be added later
        }

        public async Task ResetToDefaultStateAsync()
        {
            _lastSavedState = null;
        }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IReadOnlyList<string>> GetSupportedMigrations()
        {
            return new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IReadOnlyList<string>>();
        }

        public async Task PreSaveCleanupAsync()
        {
            // No cleanup needed
        }

        public async Task PostLoadInitializationAsync()
        {
            // No special initialization needed
        }

        #endregion
    }

    /// <summary>
    /// Simple implementation of ISaveSectionData for construction system
    /// </summary>
    public class ConstructionSectionData : ISaveSectionData
    {
        public ConstructionStateDTO ConstructionState;

        public string SectionKey { get; set; } = "construction";
        public string DataVersion { get; set; } = "1.0.0";
        public DateTime Timestamp { get; set; } = DateTime.Now;
        public long EstimatedSize => 1024; // Estimate 1KB
        public string DataHash { get; set; } = "";

        public bool IsValid()
        {
            return ConstructionState != null && !string.IsNullOrEmpty(SectionKey);
        }

        public string GetSummary()
        {
            return $"Construction data created at {Timestamp}";
        }
    }
}
