using UnityEngine;
using ProjectChimera.Core;
using ProjectChimera.Core.Logging;
using System.Collections.Generic;
using System.Linq;

namespace ProjectChimera.Systems.Construction
{
    /// <summary>
    /// Specialized renderer for utility connections and flow lines.
    /// Handles connection visualization, line rendering, and connection pooling.
    /// </summary>
    public class UtilityConnectionRenderer
    {
        private readonly UtilityRenderingCore _renderingCore;

        // Connection tracking
        private Dictionary<string, UtilityConnection> _activeConnections = new Dictionary<string, UtilityConnection>();
        private Queue<UtilityConnection> _connectionPool = new Queue<UtilityConnection>();
        private List<LineRenderer> _connectionLinePool = new List<LineRenderer>();

        // Events
        public System.Action<UtilityConnection> OnConnectionCreated;
        public System.Action<UtilityConnection> OnConnectionRemoved;
        public System.Action<int> OnConnectionCountChanged;

        public UtilityConnectionRenderer(UtilityRenderingCore renderingCore)
        {
            _renderingCore = renderingCore;
            InitializeConnectionSystem();
        }

        private void InitializeConnectionSystem()
        {
            SetupConnectionPooling();
        }

        /// <summary>
        /// Generate utility connections for schematic
        /// </summary>
        public void GenerateUtilityConnections(UtilityNodeRenderer nodeRenderer, SchematicUtilityData utilityData)
        {
            foreach (UtilityType utilityType in System.Enum.GetValues(typeof(UtilityType)))
            {
                var nodes = nodeRenderer.GetNodesOfType(utilityType);
                if (nodes.Count < 2) continue;

                // Generate connections between nearby nodes
                for (int i = 0; i < nodes.Count; i++)
                {
                    for (int j = i + 1; j < nodes.Count; j++)
                    {
                        var distance = Vector3.Distance(nodes[i].Position, nodes[j].Position);
                        if (distance <= GetMaxConnectionDistance(utilityType))
                        {
                            CreateConnection(nodes[i], nodes[j]);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Create connection between two nodes
        /// </summary>
        public void CreateConnection(UtilityNode fromNode, UtilityNode toNode)
        {
            if (_connectionPool.Count == 0)
            {
                UnityEngine.Debug.Log("Operation completed");
                return;
            }

            var connection = _connectionPool.Dequeue();
            connection.ConnectionId = System.Guid.NewGuid().ToString();
            connection.FromNode = fromNode;
            connection.ToNode = toNode;
            connection.UtilityType = fromNode.UtilityType;
            connection.Capacity = Mathf.Min(fromNode.Capacity, toNode.Capacity);
            connection.CurrentFlow = 0f;
            connection.IsValid = ValidateConnection(fromNode, toNode);

            // Create visual line
            connection.LineRenderer = CreateConnectionLine(fromNode.Position, toNode.Position, connection.UtilityType);

            _activeConnections[connection.ConnectionId] = connection;
            OnConnectionCreated?.Invoke(connection);
            OnConnectionCountChanged?.Invoke(_activeConnections.Count);
        }

        /// <summary>
        /// Remove connection by ID
        /// </summary>
        public void RemoveConnection(string connectionId)
        {
            if (_activeConnections.TryGetValue(connectionId, out var connection))
            {
                ReturnConnectionToPool(connection);
                _activeConnections.Remove(connectionId);
                OnConnectionRemoved?.Invoke(connection);
                OnConnectionCountChanged?.Invoke(_activeConnections.Count);
            }
        }

        /// <summary>
        /// Update connection visuals and positions
        /// </summary>
        public void UpdateConnections()
        {
            foreach (var connection in _activeConnections.Values)
            {
                if (connection.LineRenderer != null)
                {
                    connection.LineRenderer.SetPosition(0, connection.FromNode.Position);
                    connection.LineRenderer.SetPosition(1, connection.ToNode.Position);

                    // Update connection flow visualization
                    UpdateConnectionFlow(connection);
                }
            }
        }

        /// <summary>
        /// Set visibility for connections of specific utility type
        /// </summary>
        public void SetUtilityTypeVisible(UtilityType utilityType, bool visible)
        {
            foreach (var connection in _activeConnections.Values)
            {
                if (connection.UtilityType == utilityType && connection.LineRenderer != null)
                {
                    connection.LineRenderer.enabled = visible;
                }
            }
        }

        /// <summary>
        /// Get connection info at position within radius
        /// </summary>
        public List<UtilityConnectionInfo> GetConnectionInfoAtPosition(Vector3 worldPosition, float radius = 1f)
        {
            var connections = new List<UtilityConnectionInfo>();

            foreach (var connection in _activeConnections.Values)
            {
                if (IsConnectionNearPosition(connection, worldPosition, radius))
                {
                    connections.Add(new UtilityConnectionInfo
                    {
                        ConnectionId = connection.ConnectionId,
                        UtilityType = connection.UtilityType,
                        FromNode = connection.FromNode,
                        ToNode = connection.ToNode,
                        Capacity = connection.Capacity,
                        CurrentFlow = connection.CurrentFlow,
                        IsValid = connection.IsValid
                    });
                }
            }

            return connections;
        }

        /// <summary>
        /// Update connection validation status
        /// </summary>
        public void UpdateConnectionValidation()
        {
            if (!_renderingCore.ShowConnectionValidation) return;

            foreach (var connection in _activeConnections.Values)
            {
                bool wasValid = connection.IsValid;
                connection.IsValid = ValidateConnection(connection.FromNode, connection.ToNode);

                if (wasValid != connection.IsValid && connection.LineRenderer != null)
                {
                    // Update connection color based on validation
                    var material = connection.LineRenderer.material;
                    material.color = connection.IsValid ?
                        _renderingCore.GetUtilityColor(connection.UtilityType) :
                        Color.red;
                }
            }
        }

        /// <summary>
        /// Get all active connections
        /// </summary>
        public IEnumerable<UtilityConnection> GetActiveConnections()
        {
            return _activeConnections.Values;
        }

        /// <summary>
        /// Get connections of specific utility type
        /// </summary>
        public IEnumerable<UtilityConnection> GetConnectionsOfType(UtilityType utilityType)
        {
            return _activeConnections.Values.Where(c => c.UtilityType == utilityType);
        }

        /// <summary>
        /// Clear all connections
        /// </summary>
        public void ClearAllConnections()
        {
            foreach (var connection in _activeConnections.Values)
            {
                ReturnConnectionToPool(connection);
                OnConnectionRemoved?.Invoke(connection);
            }
            _activeConnections.Clear();
            OnConnectionCountChanged?.Invoke(0);
        }

        /// <summary>
        /// Get active connection count
        /// </summary>
        public int GetActiveConnectionCount()
        {
            return _activeConnections.Count;
        }

        private void SetupConnectionPooling()
        {
            _connectionPool = new Queue<UtilityConnection>();

            // Pre-allocate connection objects
            for (int i = 0; i < _renderingCore.MaxVisibleConnections; i++)
            {
                var connection = new UtilityConnection();
                _connectionPool.Enqueue(connection);
            }

            // Pre-allocate LineRenderer objects
            for (int i = 0; i < _renderingCore.MaxVisibleConnections; i++)
            {
                var lineRenderer = CreatePooledLineRenderer();
                lineRenderer.gameObject.SetActive(false);
                _connectionLinePool.Add(lineRenderer);
            }
        }

        private LineRenderer CreateConnectionLine(Vector3 start, Vector3 end, UtilityType utilityType)
        {
            LineRenderer lineRenderer = null;

            // Try to get from pool
            var availableLine = _connectionLinePool.FirstOrDefault(lr => !lr.gameObject.activeInHierarchy);
            if (availableLine != null)
            {
                lineRenderer = availableLine;
                lineRenderer.gameObject.SetActive(true);
            }
            else
            {
                lineRenderer = CreatePooledLineRenderer();
            }

            // Configure line renderer
            lineRenderer.gameObject.name = $"UtilityConnection_{utilityType}";

            // Set material color for utility type
            var materialInstance = new Material(_renderingCore.GetRenderingMaterial(UtilityRenderingMaterialType.Connection));
            materialInstance.color = _renderingCore.GetUtilityColor(utilityType);
            lineRenderer.material = materialInstance;
            lineRenderer.startWidth = _renderingCore.ConnectionLineWidth;
            lineRenderer.endWidth = _renderingCore.ConnectionLineWidth;
            lineRenderer.positionCount = 2;
            lineRenderer.useWorldSpace = true;
            lineRenderer.sortingOrder = 100;

            lineRenderer.SetPosition(0, start);
            lineRenderer.SetPosition(1, end);

            return lineRenderer;
        }

        private LineRenderer CreatePooledLineRenderer()
        {
            var lineObj = new GameObject("UtilityConnectionPool");
            lineObj.layer = _renderingCore.UtilityLayer;

            var lineRenderer = lineObj.AddComponent<LineRenderer>();
            lineRenderer.material = _renderingCore.GetRenderingMaterial(UtilityRenderingMaterialType.Connection);

            return lineRenderer;
        }

        private void UpdateConnectionFlow(UtilityConnection connection)
        {
            if (connection.IsValid)
            {
                connection.CurrentFlow = Mathf.Min(connection.Capacity, GetCalculatedFlow(connection));

                // Update line thickness based on flow
                if (connection.LineRenderer != null)
                {
                    float flowRatio = connection.CurrentFlow / connection.Capacity;
                    float thickness = _renderingCore.ConnectionLineWidth * (0.5f + flowRatio * 0.5f);
                    connection.LineRenderer.startWidth = thickness;
                    connection.LineRenderer.endWidth = thickness;
                }
            }
            else
            {
                connection.CurrentFlow = 0f;
            }
        }

        private bool ValidateConnection(UtilityNode fromNode, UtilityNode toNode)
        {
            // Basic validation - can be expanded with more complex rules
            if (fromNode.UtilityType != toNode.UtilityType) return false;

            float distance = Vector3.Distance(fromNode.Position, toNode.Position);
            return distance <= GetMaxConnectionDistance(fromNode.UtilityType);
        }

        private float GetMaxConnectionDistance(UtilityType utilityType)
        {
            return utilityType switch
            {
                UtilityType.Electrical => 5f,
                UtilityType.Water => 3f,
                UtilityType.Air => 4f,
                UtilityType.Data => 6f,
                _ => 3f
            };
        }

        private float GetCalculatedFlow(UtilityConnection connection)
        {
            // Simplified flow calculation - can be expanded with more complex logic
            return connection.Capacity * 0.7f; // Assume 70% capacity utilization
        }

        private bool IsConnectionNearPosition(UtilityConnection connection, Vector3 position, float radius)
        {
            Vector3 lineStart = connection.FromNode.Position;
            Vector3 lineEnd = connection.ToNode.Position;

            Vector3 closestPoint = GetClosestPointOnLine(lineStart, lineEnd, position);
            return Vector3.Distance(closestPoint, position) <= radius;
        }

        private Vector3 GetClosestPointOnLine(Vector3 lineStart, Vector3 lineEnd, Vector3 point)
        {
            Vector3 lineDirection = lineEnd - lineStart;
            float lineLength = lineDirection.magnitude;
            lineDirection.Normalize();

            float projectedDistance = Mathf.Clamp(Vector3.Dot(point - lineStart, lineDirection), 0f, lineLength);
            return lineStart + lineDirection * projectedDistance;
        }

        private void ReturnConnectionToPool(UtilityConnection connection)
        {
            if (connection.LineRenderer != null)
            {
                connection.LineRenderer.gameObject.SetActive(false);
                connection.LineRenderer = null;
            }

            connection.Reset();
            _connectionPool.Enqueue(connection);
        }

        public void Cleanup()
        {
            ClearAllConnections();

            // Clean up pooled line renderers
            foreach (var lineRenderer in _connectionLinePool)
            {
                if (lineRenderer != null && lineRenderer.gameObject != null)
                    Object.DestroyImmediate(lineRenderer.gameObject);
            }
            _connectionLinePool.Clear();
        }
    }

    /// <summary>
    /// Utility connection between two nodes
    /// </summary>
    [System.Serializable]
    public class UtilityConnection
    {
        public string ConnectionId;
        public UtilityNode FromNode;
        public UtilityNode ToNode;
        public UtilityType UtilityType;
        public float Capacity;
        public float CurrentFlow;
        public bool IsValid;
        public LineRenderer LineRenderer;

        public void Reset()
        {
            ConnectionId = null;
            FromNode = null;
            ToNode = null;
            Capacity = 0f;
            CurrentFlow = 0f;
            IsValid = false;
            LineRenderer = null;
        }
    }

    /// <summary>
    /// Information about a utility connection
    /// </summary>
    [System.Serializable]
    public class UtilityConnectionInfo
    {
        public string ConnectionId;
        public UtilityType UtilityType;
        public UtilityNode FromNode;
        public UtilityNode ToNode;
        public float Capacity;
        public float CurrentFlow;
        public bool IsValid;
    }

    /// <summary>
    /// Utility data for a complete schematic
    /// </summary>
    [System.Serializable]
    public class SchematicUtilityData
    {
        public Dictionary<string, List<UtilityRequirement>> ItemRequirements = new Dictionary<string, List<UtilityRequirement>>();

        public void AddRequirements(string itemId, List<UtilityRequirement> requirements)
        {
            ItemRequirements[itemId] = requirements;
        }
    }
}
