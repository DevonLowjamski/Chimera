using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using ProjectChimera.Core.Logging;

namespace ProjectChimera.Systems.Construction
{
    /// <summary>
    /// Specialized controller for utility flow animations and visual effects.
    /// Handles flow indicators, pulse animations, and dynamic visual feedback.
    /// </summary>
    public class UtilityAnimationController
    {
        private readonly UtilityRenderingCore _renderingCore;
        
        [Header("Animation Settings")]
        [SerializeField] private bool _enableFlowAnimation = true;
        [SerializeField] private float _flowAnimationSpeed = 2f;
        [SerializeField] private bool _enablePulseIndicators = true;
        [SerializeField] private float _pulseSpeed = 1.5f;
        [SerializeField] private float _pulseIntensity = 0.4f;

        // Flow indicators
        private List<UtilityFlowIndicator> _flowIndicators = new List<UtilityFlowIndicator>();
        private Queue<GameObject> _flowIndicatorPool = new Queue<GameObject>();
        
        // Animation state
        private float _animationTime = 0f;
        
        // Events
        public System.Action<UtilityFlowIndicator> OnFlowIndicatorCreated;
        public System.Action<UtilityFlowIndicator> OnFlowIndicatorDestroyed;

        public UtilityAnimationController(UtilityRenderingCore renderingCore)
        {
            _renderingCore = renderingCore;
            InitializeAnimationSystem();
        }

        private void InitializeAnimationSystem()
        {
            // Pre-populate flow indicator pool
            for (int i = 0; i < 50; i++)
            {
                var indicator = CreatePooledFlowIndicator();
                indicator.SetActive(false);
                _flowIndicatorPool.Enqueue(indicator);
            }
        }

        /// <summary>
        /// Update all animations
        /// </summary>
        public void UpdateAnimations(float deltaTime)
        {
            _animationTime += deltaTime;

            if (_enableFlowAnimation)
            {
                UpdateFlowAnimations();
            }

            if (_enablePulseIndicators)
            {
                UpdatePulseAnimations();
            }

            UpdateFlowIndicators();
        }

        /// <summary>
        /// Generate flow indicators for all valid connections
        /// </summary>
        public void GenerateFlowIndicators(UtilityConnectionRenderer connectionRenderer)
        {
            if (!_renderingCore.ShowFlowDirections) return;

            ClearFlowIndicators();

            foreach (var connection in connectionRenderer.GetActiveConnections())
            {
                if (connection.IsValid && connection.CurrentFlow > 0f)
                {
                    CreateFlowIndicator(connection);
                }
            }
        }

        /// <summary>
        /// Create flow indicator for specific connection
        /// </summary>
        public void CreateFlowIndicator(UtilityConnection connection)
        {
            var midPoint = (connection.FromNode.Position + connection.ToNode.Position) * 0.5f;
            var direction = (connection.ToNode.Position - connection.FromNode.Position).normalized;

            var indicator = new UtilityFlowIndicator
            {
                IndicatorId = System.Guid.NewGuid().ToString(),
                Connection = connection,
                Position = midPoint,
                FlowDirection = direction,
                FlowSpeed = _flowAnimationSpeed,
                IsActive = true
            };

            // Create visual arrow
            indicator.VisualObject = CreateFlowArrow(midPoint, direction, connection.ConstructionUtilityType);

            _flowIndicators.Add(indicator);
            OnFlowIndicatorCreated?.Invoke(indicator);
        }

        /// <summary>
        /// Remove flow indicator
        /// </summary>
        public void RemoveFlowIndicator(string indicatorId)
        {
            var indicator = _flowIndicators.FirstOrDefault(fi => fi.IndicatorId == indicatorId);
            if (indicator != null)
            {
                ReturnFlowIndicatorToPool(indicator.VisualObject);
                _flowIndicators.Remove(indicator);
                OnFlowIndicatorDestroyed?.Invoke(indicator);
            }
        }

        /// <summary>
        /// Clear all flow indicators
        /// </summary>
        public void ClearFlowIndicators()
        {
            foreach (var indicator in _flowIndicators)
            {
                ReturnFlowIndicatorToPool(indicator.VisualObject);
                OnFlowIndicatorDestroyed?.Invoke(indicator);
            }
            _flowIndicators.Clear();
        }

        /// <summary>
        /// Apply pulse animation to nodes
        /// </summary>
        public void ApplyPulseToNodes(UtilityNodeRenderer nodeRenderer)
        {
            if (!_enablePulseIndicators) return;
            
            float pulse = 1f + Mathf.Sin(_animationTime * _pulseSpeed) * _pulseIntensity;
            nodeRenderer.ApplyPulseAnimation(pulse);
        }

        /// <summary>
        /// Set flow animation enabled state
        /// </summary>
        public void SetFlowAnimationEnabled(bool enabled)
        {
            _enableFlowAnimation = enabled;
        }

        /// <summary>
        /// Set pulse animation enabled state
        /// </summary>
        public void SetPulseAnimationEnabled(bool enabled)
        {
            _enablePulseIndicators = enabled;
        }

        /// <summary>
        /// Update flow animation speed
        /// </summary>
        public void SetFlowAnimationSpeed(float speed)
        {
            _flowAnimationSpeed = speed;
            
            // Update existing indicators
            foreach (var indicator in _flowIndicators)
            {
                indicator.FlowSpeed = speed;
            }
        }

        /// <summary>
        /// Update pulse animation settings
        /// </summary>
        public void SetPulseAnimationSettings(float speed, float intensity)
        {
            _pulseSpeed = speed;
            _pulseIntensity = intensity;
        }

        /// <summary>
        /// Get flow indicator count
        /// </summary>
        public int GetFlowIndicatorCount()
        {
            return _flowIndicators.Count;
        }

        /// <summary>
        /// Get flow indicators for specific utility type
        /// </summary>
        public IEnumerable<UtilityFlowIndicator> GetFlowIndicatorsForType(ConstructionUtilityType utilityType)
        {
            return _flowIndicators.Where(fi => fi.Connection.ConstructionUtilityType == utilityType);
        }

        private void UpdateFlowAnimations()
        {
            foreach (var indicator in _flowIndicators)
            {
                if (indicator.IsActive && indicator.VisualObject != null)
                {
                    // Animate flow movement along connection
                    float t = Mathf.PingPong(_animationTime * indicator.FlowSpeed, 1f);
                    Vector3 animatedPos = Vector3.Lerp(
                        indicator.Connection.FromNode.Position,
                        indicator.Connection.ToNode.Position,
                        t
                    );

                    indicator.VisualObject.transform.position = animatedPos;
                    
                    // Update flow direction based on animation
                    var direction = (indicator.Connection.ToNode.Position - indicator.Connection.FromNode.Position).normalized;
                    indicator.VisualObject.transform.rotation = Quaternion.LookRotation(direction);
                    
                    // Scale based on flow rate
                    float flowRatio = indicator.Connection.CurrentFlow / indicator.Connection.Capacity;
                    float scale = 0.5f + flowRatio * 0.5f;
                    indicator.VisualObject.transform.localScale = new Vector3(0.1f, 0.1f, _renderingCore.FlowArrowSize) * scale;
                }
            }
        }

        private void UpdatePulseAnimations()
        {
            // Pulse animation is handled in ApplyPulseToNodes method
            // This method can be used for additional pulse effects
        }

        private void UpdateFlowIndicators()
        {
            // Update flow indicator states based on connection validity
            var indicatorsToRemove = new List<UtilityFlowIndicator>();
            
            foreach (var indicator in _flowIndicators)
            {
                if (!indicator.Connection.IsValid || indicator.Connection.CurrentFlow <= 0f)
                {
                    indicatorsToRemove.Add(indicator);
                }
                else
                {
                    // Update indicator properties based on connection state
                    UpdateFlowIndicatorProperties(indicator);
                }
            }
            
            // Remove invalid indicators
            foreach (var indicator in indicatorsToRemove)
            {
                RemoveFlowIndicator(indicator.IndicatorId);
            }
        }

        private void UpdateFlowIndicatorProperties(UtilityFlowIndicator indicator)
        {
            if (indicator.VisualObject != null)
            {
                // Update color based on flow rate
                var renderer = indicator.VisualObject.GetComponent<Renderer>();
                if (renderer != null)
                {
                    float flowRatio = indicator.Connection.CurrentFlow / indicator.Connection.Capacity;
                    var baseColor = _renderingCore.GetUtilityColor(indicator.Connection.ConstructionUtilityType);
                    var flowColor = Color.Lerp(baseColor * 0.5f, baseColor, flowRatio);
                    renderer.material.color = flowColor;
                }
                
                // Update visibility based on flow state
                bool shouldBeVisible = indicator.Connection.IsValid && indicator.Connection.CurrentFlow > 0f;
                indicator.VisualObject.SetActive(shouldBeVisible);
            }
        }

        private GameObject CreateFlowArrow(Vector3 position, Vector3 direction, ConstructionUtilityType utilityType)
        {
            GameObject arrowObj;

            // Try to get from pool
            if (_flowIndicatorPool.Count > 0)
            {
                arrowObj = _flowIndicatorPool.Dequeue();
                arrowObj.SetActive(true);
            }
            else
            {
                arrowObj = CreatePooledFlowIndicator();
            }

            // Configure arrow
            arrowObj.name = $"FlowIndicator_{utilityType}";
            arrowObj.transform.position = position;
            arrowObj.transform.rotation = Quaternion.LookRotation(direction);
            arrowObj.transform.localScale = new Vector3(0.1f, 0.1f, _renderingCore.FlowArrowSize);

            // Set material
            var renderer = arrowObj.GetComponent<Renderer>();
            if (renderer != null)
            {
                var material = new Material(_renderingCore.GetRenderingMaterial(UtilityRenderingMaterialType.FlowIndicator));
                material.color = _renderingCore.GetUtilityColor(utilityType);
                renderer.material = material;
            }

            return arrowObj;
        }

        private GameObject CreatePooledFlowIndicator()
        {
            var arrowObj = GameObject.CreatePrimitive(PrimitiveType.Cube);
            arrowObj.layer = _renderingCore.UtilityLayer;

            // Remove collider for performance
            if (arrowObj.GetComponent<Collider>())
                Object.DestroyImmediate(arrowObj.GetComponent<Collider>());

            return arrowObj;
        }

        private void ReturnFlowIndicatorToPool(GameObject indicatorVisual)
        {
            if (indicatorVisual != null)
            {
                indicatorVisual.SetActive(false);
                indicatorVisual.transform.position = Vector3.zero;
                indicatorVisual.transform.rotation = Quaternion.identity;
                indicatorVisual.transform.localScale = Vector3.one;
                _flowIndicatorPool.Enqueue(indicatorVisual);
            }
        }

        public void Cleanup()
        {
            ClearFlowIndicators();
            
            // Clear pool
            while (_flowIndicatorPool.Count > 0)
            {
                var indicator = _flowIndicatorPool.Dequeue();
                if (indicator != null)
                    Object.DestroyImmediate(indicator);
            }
        }
    }

    /// <summary>
    /// Flow indicator for animated utility flow
    /// </summary>
    [System.Serializable]
    public class UtilityFlowIndicator
    {
        public string IndicatorId;
        public UtilityConnection Connection;
        public Vector3 Position;
        public Vector3 FlowDirection;
        public float FlowSpeed;
        public bool IsActive;
        public GameObject VisualObject;
    }
}