name: Project Chimera CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  UNITY_VERSION: 2022.3.20f1
  UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}

jobs:
  # Phase 1: Static Analysis & Quality Gates
  static-analysis:
    name: Static Analysis & Quality Gates
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        lfs: true
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
        
    - name: Install Analysis Tools
      run: |
        dotnet tool install --global Microsoft.CodeAnalysis.Analyzers
        dotnet tool install --global Roslynator.CommandLine
        
    - name: Enhanced Quality Gates - Anti-Pattern Detection
      run: |
        echo "üîç Running Enhanced Quality Gates with Smart Anti-Pattern Detection..."

        # Create enhanced quality gate runner script - exact mirror of QualityGates.cs logic
        cat > quality_gate_runner.py << 'EOF'
        import os
        import re
        import sys

        # Enhanced forbidden patterns (mirrors QualityGates.cs exactly)
        FORBIDDEN_PATTERNS = [
            r"FindObjectOfType<",
            r"FindObjectsOfType<",
            r"GameObject\.Find\(",
            r"Resources\.Load",
            r"Debug\.Log\(",
            r"Debug\.LogWarning\(",
            r"Debug\.LogError\(",
            r"\.GetField\(",
            r"\.GetProperty\(",
            r"\.GetMethod\(",
            r"typeof\([^)]+\)\.GetProperty",
            r"Activator\.CreateInstance",
            r"Assembly\.Load"
        ]
        
        def check_anti_patterns():
            violations = []
            cs_files = []
            
            # Find all C# files excluding Testing and Editor
            for root, dirs, files in os.walk('Assets/ProjectChimera'):
                if 'Testing' in root or 'Editor' in root:
                    continue
                for file in files:
                    if file.endswith('.cs'):
                        cs_files.append(os.path.join(root, file))
            
            print(f"üìÅ Analyzing {len(cs_files)} C# files...")
            
            for file_path in cs_files:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        lines = f.readlines()
                    
                    for i, line in enumerate(lines, 1):
                        line_content = line.strip()
                        
                        # Smart filtering - exact mirror of QualityGates.cs logic
                        # Skip comments and legitimate fallback mechanisms
                        if '//' in line_content and ('Fallback' in line_content or 'ServiceContainer' in line_content):
                            continue
                        
                        # Skip UnityEngine.Object prefix (legitimate fallback usage)
                        if 'UnityEngine.Object.FindObject' in line_content:
                            continue
                        
                        # Skip ChimeraLogger calls (legitimate logging)
                        if 'ChimeraLogger.Log' in line_content:
                            continue
                        
                        # Skip QualityGateRunner Debug.Log calls (legitimate for testing)
                        if 'QualityGateRunner.cs' in file and ('Debug.Log' in line_content or 'Debug.LogError' in line_content or 'Debug.LogWarning' in line_content):
                            continue
                        
                        # Skip legitimate ServiceContainer reflection usage
                        if ('ServiceContainer' in line_content or 'ServiceCollection' in line_content) and ('.GetMethod(' in line_content):
                            continue
                        
                        # Skip legitimate Resources.Load for audio/data loading services
                        if ('AudioLoadingService' in file or 'DataManager' in file) and 'Resources.Load' in line_content:
                            continue
                        
                        # Skip legitimate Activator.CreateInstance in ServiceContainer
                        if 'ServiceContainer' in file and 'Activator.CreateInstance' in line_content:
                            continue
                        
                        # Skip QualityGates.cs itself (contains patterns as strings)
                        if 'QualityGates.cs' in file:
                            continue
                            
                        for pattern in FORBIDDEN_PATTERNS:
                            if re.search(pattern, line_content):
                                violations.append({
                                    'file': file_path,
                                    'line': i,
                                    'pattern': pattern,
                                    'content': line_content
                                })
                
                except Exception as e:
                    print(f"‚ö†Ô∏è Warning: Could not analyze {file_path}: {e}")
            
            return violations
        
        def main():
            print("üîç Project Chimera Enhanced Quality Gates")
            print("=" * 60)
            
            violations = check_anti_patterns()
            
            if not violations:
                print("‚úÖ ALL QUALITY GATES PASSED!")
                print("üéâ Zero anti-pattern violations found - architecture is clean!")
                return 0
            
            print(f"‚ùå CRITICAL VIOLATIONS DETECTED: {len(violations)} anti-patterns found")
            print("üí• BLOCKING COMMIT - Architecture regression detected!")
            print()
            
            for violation in violations:
                print(f"üö´ {os.path.basename(violation['file'])}:{violation['line']}")
                print(f"   Pattern: {violation['pattern']}")
                print(f"   Content: {violation['content']}")
                print()
            
            print("=" * 60)
            print("‚ùå QUALITY GATE FAILURE - Fix violations before proceeding")
            return 1
        
        if __name__ == '__main__':
            sys.exit(main())
        EOF
        
        python3 quality_gate_runner.py
        
    - name: Quality Gates C# Validation
      run: |
        echo "üîç Running native C# Quality Gates validation..."
        
        # Create validation runner that uses our actual QualityGates.cs
        cat > validate_quality_gates.cs << 'EOF'
        using System;
        using System.IO;
        using System.Linq;
        using ProjectChimera.CI;
        
        public static class QualityGateValidator
        {
            public static int Main()
            {
                try
                {
                    Console.WriteLine("üîç Project Chimera Enhanced Quality Gates - C# Validation");
                    Console.WriteLine(new string('=', 60));
                    
                    var results = QualityGates.RunAllChecks();
                    
                    if (!results.HasViolations)
                    {
                        Console.WriteLine("‚úÖ ALL QUALITY GATES PASSED!");
                        Console.WriteLine("üéâ Zero violations found - architecture is clean!");
                        return 0;
                    }
                    
                    Console.WriteLine($"‚ùå CRITICAL VIOLATIONS DETECTED: {results.TotalViolations} total");
                    Console.WriteLine("üí• BLOCKING COMMIT - Architecture regression detected!");
                    Console.WriteLine();
                    
                    if (results.AntiPatternViolations?.Count > 0)
                    {
                        Console.WriteLine($"üö´ ANTI-PATTERN VIOLATIONS: {results.AntiPatternViolations.Count}");
                        foreach (var violation in results.AntiPatternViolations)
                        {
                            Console.WriteLine($"   {Path.GetFileName(violation.File)}:{violation.LineNumber}");
                            Console.WriteLine($"   Pattern: {violation.Pattern}");
                            Console.WriteLine($"   Content: {violation.Content}");
                            Console.WriteLine();
                        }
                    }
                    
                    if (results.FileSizeViolations?.Count > 0)
                    {
                        Console.WriteLine($"üìè FILE SIZE VIOLATIONS: {results.FileSizeViolations.Count}");
                        foreach (var violation in results.FileSizeViolations)
                        {
                            Console.WriteLine($"   {Path.GetFileName(violation.File)}: {violation.LineCount}/{violation.MaxAllowed} lines");
                        }
                        Console.WriteLine();
                    }
                    
                    Console.WriteLine(new string('=', 60));
                    Console.WriteLine("‚ùå QUALITY GATE FAILURE - Fix violations before proceeding");
                    return 1;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"üí• Quality Gate Validation Error: {ex.Message}");
                    return 1;
                }
            }
        }
        EOF
        
        # Compile and run C# validation (if available)
        if command -v csc >/dev/null; then
            echo "Compiling C# Quality Gate validator..."
            csc validate_quality_gates.cs -reference:Assets/ProjectChimera/CI/QualityGates.cs || echo "‚ö†Ô∏è C# compilation not available - using Python fallback"
        else
            echo "‚ö†Ô∏è C# compiler not available - Python validation completed above"
        fi
        
    - name: Dependency Injection Validation
      run: |
        echo "üîç Validating dependency injection patterns..."
        
        # Check for deprecated ServiceLocator usage (should be replaced with ServiceContainer)
        LEGACY_SERVICELOCATOR=$(grep -r "ServiceLocator\." Assets/ProjectChimera --include="*.cs" --exclude-dir="Testing" --exclude-dir="Editor" | grep -v "// Fallback" | wc -l)
        if [ "$LEGACY_SERVICELOCATOR" -gt 0 ]; then
          echo "‚ùå FAIL: $LEGACY_SERVICELOCATOR legacy ServiceLocator usage detected - migrate to ServiceContainer"
          grep -r "ServiceLocator\." Assets/ProjectChimera --include="*.cs" --exclude-dir="Testing" --exclude-dir="Editor" | head -10
          exit 1
        fi
        
        # Check for proper ServiceContainer usage
        SERVICE_CONTAINER_USAGE=$(grep -r "ServiceContainerFactory\.Instance" Assets/ProjectChimera --include="*.cs" --exclude-dir="Testing" | wc -l)
        echo "‚úÖ ServiceContainer usage count: $SERVICE_CONTAINER_USAGE"
        
        # Check for deprecated DependencyInjection namespace usage
        DEPRECATED_DI_NAMESPACE=$(grep -r "using ProjectChimera\.Core\.DependencyInjection" Assets/ProjectChimera --include="*.cs" --exclude-dir="Testing" | wc -l)
        if [ "$DEPRECATED_DI_NAMESPACE" -gt 0 ]; then
          echo "‚ùå FAIL: $DEPRECATED_DI_NAMESPACE deprecated DI namespace usage detected"
          grep -r "using ProjectChimera\.Core\.DependencyInjection" Assets/ProjectChimera --include="*.cs" --exclude-dir="Testing" | head -5
          exit 1
        fi
        
        # Validate ServiceContainer patterns
        echo "üîç Validating ServiceContainer migration patterns..."
        FALLBACK_PATTERNS=$(grep -r "Fallback" Assets/ProjectChimera --include="*.cs" --exclude-dir="Testing" | grep -i "findObject" | wc -l)
        echo "‚úÖ Legitimate fallback patterns found: $FALLBACK_PATTERNS"
        
        echo "‚úÖ PASS: Dependency injection validation complete"
        
    - name: Code Complexity Analysis
      run: |
        echo "üîç Analyzing code complexity..."
        
        # Create complexity analysis script
        cat > complexity_analysis.py << 'EOF'
        import os
        import re
        import sys
        
        # Define complexity limits per system type
        COMPLEXITY_LIMITS = {
            'Core': {
                'max_lines': 800,
                'max_methods': 50,
                'max_cyclomatic': 15
            },
            'Systems': {
                'max_lines': 600,
                'max_methods': 40,
                'max_cyclomatic': 12
            },
            'Data': {
                'max_lines': 400,
                'max_methods': 30,
                'max_cyclomatic': 8
            },
            'UI': {
                'max_lines': 500,
                'max_methods': 35,
                'max_cyclomatic': 10
            },
            'Testing': {
                'max_lines': 1000,
                'max_methods': 100,
                'max_cyclomatic': 20
            }
        }
        
        def get_system_type(file_path):
            if '/Core/' in file_path:
                return 'Core'
            elif '/Systems/' in file_path:
                return 'Systems'
            elif '/Data/' in file_path:
                return 'Data'
            elif '/UI/' in file_path:
                return 'UI'
            elif '/Testing/' in file_path:
                return 'Testing'
            else:
                return 'Systems'  # Default to Systems limits
        
        def analyze_file_complexity(file_path):
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                lines = content.split('\n')
                non_empty_lines = [l for l in lines if l.strip() and not l.strip().startswith('//')]
                
                # Count methods (simplified)
                method_pattern = r'(public|private|protected|internal)\s+.*\s+\w+\s*\([^)]*\)\s*{'
                methods = re.findall(method_pattern, content)
                
                # Simple cyclomatic complexity (count if/while/for/switch/catch)
                complexity_keywords = ['if ', 'while ', 'for ', 'foreach ', 'switch ', 'catch ']
                cyclomatic = sum(content.count(keyword) for keyword in complexity_keywords)
                
                return {
                    'lines': len(non_empty_lines),
                    'methods': len(methods),
                    'cyclomatic': cyclomatic
                }
            except Exception as e:
                print(f"Warning: Could not analyze {file_path}: {e}")
                return {'lines': 0, 'methods': 0, 'cyclomatic': 0}
        
        def main():
            violations = []
            
            for root, dirs, files in os.walk('Assets/ProjectChimera'):
                for file in files:
                    if file.endswith('.cs'):
                        file_path = os.path.join(root, file)
                        system_type = get_system_type(file_path)
                        limits = COMPLEXITY_LIMITS[system_type]
                        
                        metrics = analyze_file_complexity(file_path)
                        
                        if metrics['lines'] > limits['max_lines']:
                            violations.append(f"{file_path}: {metrics['lines']} lines (limit: {limits['max_lines']} for {system_type})")
                        
                        if metrics['methods'] > limits['max_methods']:
                            violations.append(f"{file_path}: {metrics['methods']} methods (limit: {limits['max_methods']} for {system_type})")
                        
                        if metrics['cyclomatic'] > limits['max_cyclomatic']:
                            violations.append(f"{file_path}: {metrics['cyclomatic']} cyclomatic complexity (limit: {limits['max_cyclomatic']} for {system_type})")
            
            if violations:
                print("‚ùå COMPLEXITY VIOLATIONS:")
                for violation in violations:
                    print(f"  - {violation}")
                sys.exit(1)
            else:
                print("‚úÖ PASS: All files within complexity limits")
        
        if __name__ == '__main__':
            main()
        EOF
        
        python3 complexity_analysis.py

    - name: File Size Quality Gates
      run: |
        echo "üîç Enforcing file size limits..."
        python3 Assets/ProjectChimera/CI/enforce_file_size_limits.py

    - name: Update Method Quality Gates
      run: |
        echo "üîç Enforcing Update() method ban..."
        python3 Assets/ProjectChimera/CI/enforce_update_method_ban.py

    - name: Resources.Load Quality Gates
      run: |
        echo "üîç Enforcing Resources.Load best practices..."
        python3 Assets/ProjectChimera/CI/enforce_resources_load_ban.py

  # Phase 2: Unity Build & Test
  unity-build:
    name: Unity Build & Test
    needs: static-analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        lfs: true
        
    - name: Cache Unity Library
      uses: actions/cache@v3
      with:
        path: Library
        key: Library-${{ hashFiles('Assets/**', 'Packages/**', 'ProjectSettings/**') }}
        restore-keys: Library-
        
    - name: Setup Unity
      uses: game-ci/unity-builder@v4
      env:
        UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
      with:
        targetPlatform: StandaloneWindows64
        
    - name: Run Unity Tests
      uses: game-ci/unity-test-runner@v4
      env:
        UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
      with:
        githubToken: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Upload Test Results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results
        path: artifacts/
        
  # Phase 3: Performance Benchmarks
  performance-tests:
    name: Performance Benchmarks
    needs: unity-build
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Setup Unity
      uses: game-ci/unity-builder@v4
      env:
        UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
      with:
        targetPlatform: StandaloneLinux64
        buildMethod: ProjectChimera.CI.PerformanceBuildMethod
        
    - name: Run Performance Benchmarks
      run: |
        echo "üéØ Running performance benchmarks..."
        # This would run the built application with performance test scenes
        # and capture frame time metrics, memory usage, etc.
        echo "Performance benchmarks completed - see artifacts for detailed results"
        
    - name: Upload Performance Results
      uses: actions/upload-artifact@v3
      with:
        name: performance-results
        path: performance-results.json

  # Phase 4: Code Coverage
  code-coverage:
    name: Code Coverage Analysis
    needs: unity-build
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Generate Coverage Report
      uses: game-ci/unity-test-runner@v4
      env:
        UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
      with:
        githubToken: ${{ secrets.GITHUB_TOKEN }}
        coverageOptions: 'generateAdditionalMetrics;generateHtmlReport;generateBadgeReport'
        
    - name: Upload Coverage Reports
      uses: actions/upload-artifact@v3
      with:
        name: coverage-results
        path: |
          CodeCoverage/
          coverage.xml
          
    - name: Coverage Gate
      run: |
        # Parse coverage results and fail if below 80%
        if command -v xmllint >/dev/null; then
          COVERAGE=$(xmllint --xpath "string(//coverage/@line-rate)" coverage.xml 2>/dev/null || echo "0")
          COVERAGE_PERCENT=$(echo "$COVERAGE * 100" | bc -l | cut -d. -f1)
          
          if [ "$COVERAGE_PERCENT" -lt 80 ]; then
            echo "‚ùå FAIL: Code coverage is ${COVERAGE_PERCENT}% (minimum: 80%)"
            exit 1
          else
            echo "‚úÖ PASS: Code coverage is ${COVERAGE_PERCENT}%"
          fi
        else
          echo "‚ö†Ô∏è  SKIP: Coverage parsing not available"
        fi

  # Phase 5: Security Scan
  security-scan:
    name: Security Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: csharp
        
    - name: Autobuild
      uses: github/codeql-action/autobuild@v3
      
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3

  # Phase 6: Documentation & Architecture Validation
  documentation-check:
    name: Documentation & Architecture Validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Check Documentation
      run: |
        echo "üîç Validating documentation coverage..."
        
        # Check for missing XML documentation on public APIs
        MISSING_DOCS=$(find Assets/ProjectChimera -name "*.cs" -exec grep -l "public class\|public interface\|public enum" {} \; | xargs -I {} bash -c 'if ! grep -q "/// <summary>" "{}"; then echo "{}"; fi' | head -10)
        
        if [ ! -z "$MISSING_DOCS" ]; then
          echo "‚ö†Ô∏è  WARNING: Some public APIs missing documentation:"
          echo "$MISSING_DOCS"
        else
          echo "‚úÖ PASS: Documentation coverage acceptable"
        fi
        
    - name: Architecture Validation
      run: |
        echo "üîç Validating architectural patterns..."
        
        # Check for proper namespace organization
        NAMESPACE_VIOLATIONS=$(grep -r "namespace " Assets/ProjectChimera --include="*.cs" | grep -v "namespace ProjectChimera" | head -5)
        
        if [ ! -z "$NAMESPACE_VIOLATIONS" ]; then
          echo "‚ö†Ô∏è  WARNING: Non-standard namespace usage detected:"
          echo "$NAMESPACE_VIOLATIONS"
        fi
        
        echo "‚úÖ PASS: Architecture validation complete"

  # Final: Deployment (only on main branch)
  deploy:
    name: Deploy Build Artifacts
    needs: [static-analysis, unity-build, performance-tests, code-coverage, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Download Build Artifacts
      uses: actions/download-artifact@v3
      
    - name: Package Release
      run: |
        echo "üì¶ Packaging release artifacts..."
        # Package builds, documentation, etc.
        
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: build-${{ github.run_number }}
        release_name: Build ${{ github.run_number }}
        draft: false
        prerelease: true